<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="th-d3-chart.html">

<polymer-element name="th-split-donut-chart" extends="th-d3-chart">

  <script>

      Polymer('th-split-donut-chart', {
        chartData: [{value: 26}, {value: 43}], // BUG: this only works when then smaller value comes first; otherwise the labels appear the same.
        colors: { foreground: "#fff" , background: "#eee", accents: ["#00c3d9", "#1f77b4"]},
        init: function() {
          var that = this,
              margin = {
                top : 10,
                right : 0,
                bottom : 10,
                left : 0,
                label: 3
              }, 
              width = that.chartWidth*0.95 - margin.left - margin.right, height = that.chartHeight*0.95 - margin.top - margin.bottom,
              pi = Math.PI,
              progress = 0,
              total = 100,
              formatPercent = d3.format(".0%"),
              outerRadius = height*0.39,
              innerRadius = height*0.25;
              this._prevProgress = 0;

            
            that.height = height;
            
            var data = [that.chartData[0].value, that.chartData[1].value];
            var foreground, text, arc;

            arc = d3.svg.arc()
              .startAngle(0*(Math.PI/180))
              .endAngle(180*(Math.PI/180))
              .innerRadius(innerRadius)
              .outerRadius(outerRadius);

            var chart_svg = that.$.chart;
            var svg = d3.select(chart_svg);

            var container = svg.attr("width", width)
                .attr("height", height)
                .append("g")
                .attr("transform", "translate(" +(width / 2 ) + "," + (height / 2) + ")");
            
            var meter = container.append("g")
                .attr("class", "progress-meter");
            
            meter.selectAll("path.background")
                .data(data)
                .enter()
                  .append("path")
                  .attr("fill", that.colors.foreground)
                  .attr("class", "background")
                  .attr("transform", function(d,i){
                    return i > 0 ? "translate(0, 5) rotate(90) scale(1,-1)" : "rotate(90) scale(-1,-1)";
                  })
                  .attr("d", arc);
            
            foreground = meter.selectAll("path.foreground")
                .data(data)
                .enter()
                  .append("path")
                  .attr("fill", function(d,i){
                    return that.colors.accents[i];
                  })
                  .attr("stroke", function(d,i){
                    return that.colors.accents[i];
                  })
                  .attr("class", "foreground")
                  .attr("transform", function(d,i){
                    return i > 0 ? "translate(0, 5) rotate(90) scale(1,-1)" : "rotate(90) scale(-1,-1)";
                  });
            
            text = meter.selectAll("text.label")
                .data(data)
                .enter()
                  .append("text")
                  .attr("class", "label")
                  .attr("fill", function(d,i){
                    return that.colors.accents[i];
                  })
                  .attr("text-anchor", "middle")
                  .attr("dy", function(d,i){
                    return i > 0 ? "2em" : "-1.5em";
                  });

            this.foreground = foreground;
            this.formatPercent = formatPercent;
            this.arc = arc;
            this.pi = pi;
            this.text = text;
            this.data = data;
            this.meter = meter;

        },
        reset: function() {
            
            
        },
        
        animate: function() {
            var total = 100;
            var that = this;
            var data = this.data;
            var meter = this.meter;

            meter.selectAll("path.foreground").transition().delay(1000).duration(1000)
              .attrTween('d', function(d){
                var i = d3.interpolate(that._prevProgress/total, d/total);
                
                return function(t) {
                  var progress = i(t);
                  
                  meter.selectAll("text.label").text(function(d){
                    return progress > d/total ? that.formatPercent(d/total) : that.formatPercent(progress);
                  })

                  return that.arc.endAngle(that.pi * progress)();
                  
                };
                this._prevProgress = progress; 
              })
        },
        chartSpecificDataValidate: function() {

          var errors = [],
              numOfSets = this.chartData.length;
              
              // There should be two values.    
              if(numOfSets != 2) {
                errors.push({input: numOfSets, msg: 'Please provide exactly two values for this chart.'});
              } else {

                // Each value should be between 1 and 100.
                for (var i=0; i < numOfSets; i++){
                  if (this.chartData[i].value > 100 || this.chartData[i].value < 1) {
                    errors.push({ input: this.chartData[i].value, msg: 'Values must be between 1 and 100' });
                  }
                }
              }

          return errors;
        }
        
      });



  </script>
</polymer-element>