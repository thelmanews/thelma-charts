<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="th-d3-chart.html">

<polymer-element name="th-line-graph-single" extends="th-d3-chart">
  <template>
    <core-style ref="theme"> </core-style>
    <style>
      #chart {
        width: 100%;
        padding: 10px;
        box-sizing: border-box;
      }

      .xLabel, .yLabel {
        font-size: 0.6em;
        font-weight: 300;
      }

      circle {
        cursor: pointer;
      }

      @-webkit-keyframes pulse {  
        from {
         stroke: rgba(255, 255, 255, 0.9);
        }
        50% {
          stroke: rgba(255, 255, 255, 0.4);
        }
        to {
          stroke: rgba(255, 255, 255, 0.9);      
        }
      }

      .tooltip {
        width: 100%;
        position: relative;
        box-sizing: border-box;
        padding: 0px 20px;
      }

      .pulse {
        -webkit-animation-name: pulse;
        -webkit-animation-duration: 3s;
        -webkit-animation-iteration-count: infinite;
        animation-timing-function: linear;
      }
    </style>
    <content></content>
    <svg id="chart"></svg> 
    <div id="info"></div> 
  </template> 
  
  <script>
    Polymer('th-line-graph-single', {
      chartOptions: {
        lineStyle: "cardinal", // options: linear, basis, cardinal, monotone, step-before/after
        animateStyle: "draw", // options: raise, draw
        animateAxis: false, // need to restyle the axis
        fillArea: true, 
        dataPosition: "left" // options: left, right
      
      },
      chartData: [
        {'label': 2010, 'value': 104,'display_value': '$104' },
        {'label': 2011, 'value': 108,'display_value': '$108' },
        {'label': 2012, 'value': 107,'display_value': '$107', 'tooltip': 'Enter a tooltip'},
        {'label': 2013, 'value': 110,'display_value': '$110', 'tooltip': 'Enter a tooltip',},
        {'label': 2014, 'value': 112,'display_value': '$112', 'tooltip': 'Enter a tooltip'}
      ],
      init: function() {
        var self = this;

        // setup dimensions
        self.dims = self.setupDimensions(self);
        self.width = self.dims.width;
        self.height = self.dims.height;

        // adjust the margins because labels and joystick need more space
        self.dims.margin.right = 10;
        self.dims.margin.left = 10;
        self.dims.margin.top = 30;
        self.dims.margin.bottom = 30;
        self.width = self.dims.width = Math.max(100,(self.chartWidth*0.95 -self.dims.margin.left - self.dims.margin.right));
      
        self._scaleBuilder();
        self._setupElements();
        self._setupElementSizes();
        self.dataLength = self.chartData.length;
      },
      _scaleBuilder: function(){
        var self = this;

        self.maxLabel = self.getBoundaryValue(self, "label", d3.max);
        self.minLabel = self.getBoundaryValue(self, "label", d3.min);
        self.maxValue = self.getBoundaryValue(self, "value", d3.max);
        self.minValue = self.getBoundaryValue(self, "value", d3.min);
        
        self.y = d3.scale.linear().domain([self.minValue, self.maxValue]).range([self.dims.margin.top, 
                (self.height-(self.dims.margin.top + self.dims.margin.bottom)) ]), //30 to make room for the slider
        self.x = d3.scale.linear().domain([self.minLabel, self.maxLabel]).range([0, self.width ]); 

      },
      _setupElements: function(){
        var self = this,
            width = self.width,
            height = self.height,
            y = self.y,
            x = self.x;

        self.svg = d3.select(self.$.chart);
        
        var g = self.svg.append("g");
        self.g = g;

        // line data
        self.startingLine = d3.svg.line()
          .x(function(d) { return x(d.label); })
          .y(0).interpolate(self.chartOptions.lineStyle);

        // x-axis
        self.xAxis = g.append("line")
          .attr("class", "axis")
          .attr("stroke-width", 2)
          .attr("x1", x(self.minLabel))
          .attr("y1", 0)
          .attr("x2", x(self.maxLabel)) 
          .attr("y2", 0);
        
        // y-axis
        self.yAxis = g.append("line")
          .attr("x1", 0)
          .attr("x2", 0)
          .attr("y1", function(d) { return self.chartOptions.animateAxis ? y(0) : -1 * y(self.minValue); }) 
          .attr("y2", function(d) { return self.chartOptions.animateAxis ? y(0) : -1 * y(self.maxValue); });
          // .attr("stroke-width", 2)
          // .attr("opacity", function(d) { return self.chartOptions.animateAxis ? 0 : 1; });

        // x labels
        g.selectAll(".xLabel")
          .data(x.ticks(5))// TODO: Replace with formula (number of labels)
          .enter().append("text")
          .attr("class", "xLabel axis")
          .text(String)
          .attr("x", function(d) { return x(d) })
          .attr("y", self.dims.margin.top/2)
          .attr("text-anchor", "middle");
          // .attr("fill", self.colors.foreground);
        
        // y labels
        self.yLabels = g.selectAll(".yLabel")
          .data(y.ticks(4)) // TODO: Replace with formula (number of labels)
          .enter().append("text")
          .attr("class", "yLabel axis")
          .text(String)
          .attr("transform", function(d){
            var yPos = self.chartOptions.animateAxis ? 0 : -1 * y(d);
            return "translate(0,"+ yPos +") rotate(-90)";
          } )
          .attr("dy", 4)
          // .attr("fill", self.colors.foreground)
          .attr("opacity", function(d) { return self.chartOptions.animateAxis ? 0 : 1; })
          .style("text-anchor", "start");

        // // x tick marks
        // g.selectAll(".xTicks")
        //   .data(x.ticks(5)) // TODO: Replace with formula (number of tickmarks)
        //   .enter().append("line")
        //   .attr("class", "xTicks")
        //   .attr("x1", function(d) { return x(d); })
        //   .attr("y1", -1 * y(0))
        //   .attr("x2", function(d) { return x(d); })
        //   .attr("y2", -1 * y(-0.5));
        //   // .attr("stroke", self.colors.foreground);
        
        // // y tick marks
        // self.yTicks = g.selectAll(".yTicks")
        //   .data(y.ticks(4)) // TODO: Replace with formula (number of tickmarks)
        //   .enter().append("line")
        //   .attr("class", "yTicks")
        //   .attr("y1", function(d) { return self.chartOptions.animateAxis ? 0 : -1 * y(d); })
        //   .attr("x1", 0)
        //   .attr("y2", function(d) { return self.chartOptions.animateAxis ? 0 : -1 * y(d); })
        //   .attr("x2", width)
        //   // .attr("stroke", self.colors.foreground)
        //   .attr("opacity", function(d) { return self.chartOptions.animateAxis ? 0 : 0.3; });
        


      },
      _setupContainerSize: function(){
        var self = this,
            width = self.width,
            height = self.height;

        self.svg
          .attr("width", width)
          .attr("height", height); 

        self.g
          .attr("transform", "translate(0,"+ (height-self.dims.margin.top/2) +")");
      
      },
      _setupElementSizes: function(){
        var self = this,  
            width = self.width,
            height = self.height,
            y = self.y,
            x = self.x;

        self._setupContainerSize();
        
        self.line = d3.svg.line()
          .x(function(d) { return x(d.label); })
          .y(function(d) { return -y(d.value); })
          .interpolate(self.chartOptions.lineStyle);

          

      },
      resize: function(){
        
      },
      updateData: function(){

      },
      reset: function() {
        var self = this,
            g = self.g,
            svg = self.svg;
        
        // removes the lines, slider and data/tooltips
        g.selectAll("path, circle, text").remove();     
        d3.select(self.$.info).selectAll("div, li").remove();  
        svg.selectAll(".slider").remove();   

      },

      animate: function() {
        var self = this;
        var g = self.g,
            svg = self.svg,
            data = self.chartData,
            line = self.line,
            x = self.x,
            y = self.y,
            minLabel = self.minLabel,
            maxLabel = self.maxLabel,
            minValue = self.minValue,
            maxValue = self.maxValue,
            startingLine = self.startingLine,
            yAxis = self.yAxis,
            yLabels = self.yLabels,
            yTicks = self.yTicks,
            h = self.height,
            w = self.width;

        var info_area = self.$.info;
        var tooltip = d3.select(info_area)
          .append("div")   
          .attr("class", "tooltip");

        var path;
        var currentPos;
        var currentTooltip;
        var currentValue;


        function drawLine(){
          var data = self.chartData,
              animationStyle = self.chartOptions.animateStyle;

          if (animationStyle === "draw"){
  
            if (self.chartOptions.fillArea){
              // area to fill under line
              var area = d3.svg.area()
                .x(function(d) { return x(d.label); })
                .y1(function(d) { return -y(d.value); }).interpolate(self.chartOptions.lineStyle);

              g.append("path")
                .datum(data)
                .attr("class", "data0")
                .attr("opacity", 0)
                .transition()
                  .duration(1000) // TODO: make variable?
                  //.delay(1000) 
                  .ease("linear")
                  .attr("stroke-dashoffset", 0)
                .attr("d", area)
                // .attr("fill", color)
                .attr("opacity", 0.7);
            }

            path = g.selectAll('.dummy').data(data)
              .enter().append("path")
              .attr("d", line(data)) 
              .attr("class", "data0 no-fill")
              // .attr("stroke", color)
              .attr("stroke-width", "3")
              .attr("fill", "none");

            var totalLength = path.node().getTotalLength();
           
            path
              .attr("stroke-dasharray", totalLength + " " + totalLength)
              .attr("stroke-dashoffset", totalLength)
              .transition()
                .duration(1000) // TODO: make variable?
                //.delay(1000) 
                .ease("linear")
                .attr("stroke-dashoffset", 0);
          } else { // raise style 
            
            if (self.chartOptions.fillArea){ 
              var areaStart = d3.svg.area()
                .x(function(d) { return x(d.label); })
                .y1(0).interpolate(self.chartOptions.lineStyle);
                    
              var area = d3.svg.area()
                .x(function(d) { return x(d.label); })
                .y1(function(d) { return -y(d.value); })
                .interpolate(self.chartOptions.lineStyle);

              g.append("path")
                .datum(data)
                .attr("class", "area data0")
                .attr("opacity", 0)
                // .attr("fill", color)
                .attr("d", areaStart)
                .transition()
                  .duration(1000)
                  .ease("linear")
                  .attr("stroke-dashoffset", 0)
                .attr("d", area)
                // .attr("fill", color)
                .attr("opacity", 0.7);
            }

             var path = g.selectAll('.dummy').data(data).enter().append("path")
              .attr("d", function(){ return self.chartOptions.fillArea ? line(data) : startingLine(data);})
              // .attr("stroke", color)
              .attr("class", "data0")
              .attr("stroke-width", "2.5")
              .attr("fill", "none")
              .attr("opacity", function(){ return self.chartOptions.fillArea ? 0 : 1;});

            path.transition()
              .duration(function(){ return self.chartOptions.fillArea ? 5000 : 1000;})
              .attr("d", line(data))
              .attr("opacity", 1);
          }

          g.selectAll(".circle")
          .data(data)
          .enter().append("circle")
          .attr("class", "circle data0 stroke-foreground")
          .attr("r", 0)
          // .attr("fill", color) 
          // .attr("stroke", self.colors.foreground)
          .attr("stroke-width", 3)
          .attr("cx", function(d) { return  x(d.label); })
          .attr("cy", function(d) { return -1 * y(d.value); })
        
        }

        function animateAxis(){
          yAxis.transition()
            .duration(1000)
            .attr("y1", -1 * 0)
            .attr("y2", -1 * y(maxValue))
            .attr("opacity", 1);

          yLabels.transition()
            .duration(1000)
            .attr("y", function(d) { return -1 * y(d) })
            .attr("opacity", 1);

          yTicks.transition()
            .duration(1000)
            .attr("y1", function(d) { return -1 * y(d) })
            .attr("y2", function(d) { return -1 * y(d) })
            .attr("opacity", 1);
        }


        if(self.chartOptions.animateAxis) {
          animateAxis();
        }

        // CALL THE DRAWLINES FUNCTION AND PASS IN THE DATA
        drawLine();


        // FIND THE FIRST TOOLTIP AND SET self AS CURRENT POSITION
        for (var i=0; i<data.length; i++){
          if (data[i].tooltip){
            currentPos = data[i].label;
            currentTooltip = data[i].tooltip;
            currentValue = data[i].display_value ? data[i].display_value : data[i].value;
            break;
          } else {
            currentPos = data[0].label;
            currentTooltip = data[0].tooltip;
            currentValue = data[0].display_value ? data[0].display_value : data[0].value;
          }
        }

        var data_area = g.append('g').append('text')
          .attr("font-size", h/3)
          .attr("x", function(){
            return self.chartOptions.dataPosition === "left" ? self.dims.margin.left : (w-self.dims.margin.left);
           })
          .attr("text-anchor", function(){
            return self.chartOptions.dataPosition === "left" ? "start" : "end";
           })
          .attr("y", -(h/2))
          .attr("class", "fill-foreground")
          // .attr("fill", self.colors.foreground)
          .attr("opacity", 0.7)
          .text(currentValue);


        function getCurrentValues(position, firstTime){
          currentValue;
          g.selectAll(".circle")
                .transition()
                .delay(function(){ return firstTime ? 1000 : 0})
                .duration(300)
                .attr("r", function(d){
                  if (parseInt(d.label)==parseInt(position)){ 
                    currentTooltip = d.tooltip;
                    currentValue = d.display_value ? d.display_value : d.value;
                    return 4;
                  } else {
                    return 0;
                  }
                });
        }

        function showCurrentValues(tooltipInfo, value){
            // show tooltip 
            tooltip.transition() 
                .duration(100)      
                .style("opacity", 1);      
            tooltip.html(tooltipInfo);  
            
            // show value
            data_area.text(value);
            
        }

        getCurrentValues(currentPos, firstTime=true);
        showCurrentValues(currentTooltip, currentValue);

        // Slider
        var currentPosX = x(currentPos);  
        var slider = svg.selectAll('g.slider')
            .data([{x: currentPosX}]) //??
            .enter()
                .append('g')
                .attr("class", "slider")
                .attr("height", 200)
                .attr("width", w);

        var drag = d3.behavior.drag()
            .origin(Object)
            .on("drag", dragMove)
            .on('dragend', dragEnd);

        slider.append("circle")
            .attr("class", "target")
            .attr("r", 8)
            .attr("cx", currentPosX)
            .attr("cy", 12)
            .attr("class", "pulse fill-background stroke-foreground")
            // .attr("fill", self.colors.background)
            // .attr("stroke", self.colors.foreground)
            .attr("stroke-width", 4.5)
            .call(drag);

        slider.append('rect')
            .attr('y', 22)
            .attr('x', currentPosX-1.5)
            .attr("height", h-36)
            .attr("width", 3)
            .attr("class", "fill-foreground")
            // .attr('fill', self.colors.foreground)
            .attr('opacity', 0.4);

        var lastPosX = slider.select("circle").attr("cx");
        var direction;
        var points = g.selectAll('.circle');
        var closestPoint;  

        function dragMove(d) {

            // move the circle
            d3.select(this)

              .attr("class", "fill-background stroke-foreground")
              .attr("cx", d.x = Math.max(0, Math.min(w, d3.event.x))); 
       
            // define current position
            currentPosX = d3.select(this).attr("cx");

            // move the line
            slider.select('rect')
              .attr('x', currentPosX-1)
              .attr('opacity', 1);

            // determine direction of slide movement
            if (currentPosX < lastPosX){
              direction = "left";
              lastPosX = currentPosX;
            } else {
              direction ="right";
              lastPosX = currentPosX;
            }
            

            // determine which circles/tooltips are to be displayed
            g.selectAll(".circle")
              .attr("r", function(d){
                if ( Math.abs(x(d.label) - parseInt(currentPosX)) < 10) {
                // (x(d.label)<(parseInt(currentPosX)+5)) && (x(d.label)>(parseInt(currentPosX)-5))){ 
                  currentTooltip = d.tooltip;
                  currentValue = d.display_value ? d.display_value : d.value;
                  return 4;
                } else {
                  return 0;
                }
              });
           

            // Find the closest point to the slider
            if (direction == "right"){
              closestPoint = d3.min(points[0], function(d){
                var cx = parseInt(d3.select(d).attr("cx")); 
                return (cx - currentPosX >= 0) ? cx : Number.MAX_VALUE  ;
              });
          
            } else {
              closestPoint = d3.max(points[0], function(d){
                var cx = parseInt(d3.select(d).attr("cx")); 
                return (cx - currentPosX < 0) ? cx : Number.MIN_VALUE  ;
              });
            }

        }

        function dragEnd() {
      
            // Lock the slider in place
            d3.select(this)
              .attr('class','pulse')
              .transition()
                .duration(50)
                .attr('cx', closestPoint);
            slider.select('rect')
              .transition()
                .duration(50)
                .attr('x', closestPoint-1) // adjusted bc of thickness of line
                .attr('opacity', 0.4);

             // Update the info below chart
            getCurrentValues(x.invert(closestPoint));
            showCurrentValues(currentTooltip, currentValue);

        }

        // BUGS
        // When u click the joystick, it jumps to the last position you let go at
        // the axis/ margin is funky. do we want to show lines? y labels?
      


      },
      chartSpecificDataValidate: function() {

        }
    });
  </script>

</polymer-element>
