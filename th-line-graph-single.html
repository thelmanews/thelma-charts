<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="th-d3-chart.html">

<polymer-element name="th-line-graph-single" extends="th-d3-chart">
  <template>
    <core-style ref="theme"> </core-style>
    <style>
      #chart {
        width: 100%;
        padding: 10px;
        box-sizing: border-box;
      }

      .xLabel, .yLabel {
        font-size: 0.6em;
        font-weight: 300;
      }

      circle {
        cursor: pointer;
      }

      @-webkit-keyframes pulse {  
        from {
         stroke: rgba(255, 255, 255, 0.9);
        }
        50% {
          stroke: rgba(255, 255, 255, 0.4);
        }
        to {
          stroke: rgba(255, 255, 255, 0.9);      
        }
      }

      .note {
        width: 100%;
        position: relative;
        box-sizing: border-box;
        padding: 0px 20px;
      }

      .pulse {
        -webkit-animation-name: pulse;
        -webkit-animation-duration: 3s;
        -webkit-animation-iteration-count: infinite;
        animation-timing-function: linear;
      }
    </style>
    <svg id="chart"></svg> 
    <div id="info"></div> 
  </template> 
  
  <script>
    Polymer('th-line-graph-single', {
      chartOptions: {
        lineStyle: "cardinal", // options: linear, basis, cardinal, monotone, step-before/after
        animateStyle: "draw", // options: raise, draw
        fillArea: false, 
        yAxisLabels: false,
        xAxisLabels: true,
        animateAxis: false, // need to restyle the axis
        dataPosition: "left",  // options: left, right
        joyStick: false
        
      },
      chartData: [
        {'label': 2010, 'value': 104,'display_value': '$104', 'note': ''},
        {'label': 2011, 'value': 108,'display_value': '$108', 'note': ''},
        {'label': 2012, 'value': 107,'display_value': '$107', 'note': ''},
        {'label': 2013, 'value': 110,'display_value': '$110', 'note': ''},
        {'label': 2014, 'value': 112,'display_value': '$112', 'note': ''}
      ],
      init: function() {
        var self = this;

        // setup dimensions
        self.dims = self.setupDimensions(self);
        self.width = self.dims.width;
        self.height = self.dims.height;

        // adjust the margins because labels and joystick need more space
        self.dims.margin.right = 10;
        self.dims.margin.left = 15;
        self.dims.margin.top = 30;
        self.dims.margin.bottom = 30;
        self.width = self.dims.width = Math.max(100,(self.chartWidth*0.95 -self.dims.margin.left - self.dims.margin.right));
      
        self._scaleBuilder();
        self._setupElements();
        self._setupElementSizes();
        self.dataLength = self.chartData.length;
      },
      _scaleBuilder: function(data){
        var self = this;

        self.maxLabel = self.getBoundaryValue(self, "label", d3.max);
        self.minLabel = self.getBoundaryValue(self, "label", d3.min);
        self.maxValue = self.getBoundaryValue(self, "value", d3.max);
        self.minValue = self.getBoundaryValue(self, "value", d3.min);
        
        self.y = d3.scale.linear().domain([self.minValue, self.maxValue]).range([self.dims.margin.top, 
                (self.height-(self.dims.margin.top + self.dims.margin.bottom)) ]), //30 to make room for the joystick
        self.x = d3.scale.linear().domain([self.minLabel, self.maxLabel]).range([self.dims.margin.left, self.width ]); 

      },
      _setupElements: function(){

        var self = this,
            width = self.width,
            height = self.height,
            y = self.y,
            x = self.x;
            g = self.g, 
            svg = self.svg,
            data = self.chartData,
            line = self.line,
            startingLine = self.startingLine,
            animationStyle = self.chartOptions.animateStyle; 

        self.currentPos = {};

        self.svg = d3.select(self.$.chart);
        
        // container
        var g = self.svg.append("g");
        self.g = g;

        // note area
        self.note = d3.select(self.$.info)
          .append("div")   
          .attr("class", "note");
     
        // x-axis
        self.xAxis = g.append("line")
          .attr("class", "axis")
          .attr("stroke-width", 2);
         
        // y-axis
        self.yAxis = g.append("line")
          .attr("x1", 0)
          .attr("x2", 0);       

        // x labels
        self.xLabels = g.selectAll(".xLabel")
          .data(x.ticks(4))// TODO: Replace with formula (number of labels)
          .enter().append("text")
          .attr("class", "xLabel axis")
          .text(function(d){ return d;})
          .attr("opacity", function(d) { return self.chartOptions.xAxisLabels ? 1 : 0; })
          .attr("text-anchor", "middle");
          
        
        // y labels
        self.yLabels = g.selectAll(".yLabel")
          .data(y.ticks(4)) // TODO: Replace with formula (number of labels)
          .enter().append("text")
          .attr("class", "yLabel axis")
          .text(function(d){ return d;})
          .attr("dy", 4)
          .attr("opacity", function(d) { return self.chartOptions.animateAxis || !self.chartOptions.yAxisLabels ? 0 : 1; })
          .style("text-anchor", "start");
        
        // large display value
        self.displayValue = g.append('g').append('text')
          .attr("class", "fill-foreground")
          .attr("opacity", function(){
            return self.chartOptions.joyStick ? 0.7 : 0;
          }); // this can start as 0 and fade in after datapoint and joystick appear

        // fill area path
        self.areaPath = g.append("path");

        // line path
        self.linePath = g.selectAll('.data0')
            .data(data)
            .enter().append("path")
            .attr("class", "data0 no-fill")
            .attr("stroke-width", "3")
            .attr("fill", "none");

        // datapoints
        self.circles = g.selectAll(".circle")
        .data(data)
        .enter().append("circle")
        .attr("class", "circle data0 stroke-foreground")
        .attr("r", 0)
        .attr("stroke-width", 3);

      },
      _setupContainerSize: function(){
        var self = this,
            width = self.width,
            height = self.height;

        self.svg
          .attr("width", width)
          .attr("height", height); 

        self.g
          .attr("transform", "translate(0,"+ (height-self.dims.margin.top/2) +")");
   
      },
      _setupElementSizes: function(){
        var self = this,  
            width = self.width,
            height = self.height,
            y = self.y,
            x = self.x,
            data = self.chartData,
            valueSize = Math.min(width, height)/3; // this should adapt if width is narrow

        self._setupContainerSize();
        
        self.xAxis
          .attr("x1", x(self.minLabel))
          .attr("y1", 0)
          .attr("x2", x(self.maxLabel)) 
          .attr("y2", 0);

        console.log("&%&%&%&%&%");
        console.log(x(self.minLabel));
        console.log(x(self.maxLabel));
        self.yAxis
          .attr("y1", function(d) { return self.chartOptions.animateAxis ? y(0) : -1 * y(self.minValue); }) 
          .attr("y2", function(d) { return self.chartOptions.animateAxis ? y(0) : -1 * y(self.maxValue); });
          // .attr("stroke-width", 2)
          // .attr("opacity", function(d) { return self.chartOptions.animateAxis ? 0 : 1; });

        self.xLabels
          // .data(x.ticks(5))// TODO: Replace with formula (number of labels)
          .text(function(d){ return d;})
          .attr("x", function(d) { return x(d) })
          .attr("y", self.dims.margin.top/2);

        self.yLabels
          .text(function(d){ return d;})
          .attr("transform", function(d){
            var yPos = self.chartOptions.animateAxis ? 0 : -1 * y(d);
            return "translate(0,"+ yPos +") rotate(-90)";
          } );


        self.displayValue
          .attr("text-anchor", function(){ return self.chartOptions.dataPosition === "left" ? "start" : "end"; })
          .attr("x", function(){ return self.chartOptions.dataPosition === "left" ? self.dims.margin.left : (width-self.dims.margin.left); })
          .attr("y", -(height - valueSize - self.dims.margin.top)) 
          .attr("font-size", valueSize) 
          .text(self.currentPos.value);

        
        // line data, starting state (raise)
        self.startingLine = d3.svg.line()
          .x(function(d) { return x(d.label); })
          .y(0).interpolate(self.chartOptions.lineStyle);

        // line data, ending state
        self.line = d3.svg.line()
          .x(function(d) { return x(d.label); })
          .y(function(d) { return -y(d.value); })
          .interpolate(self.chartOptions.lineStyle);

        // data for fill area, starting state (raise)
        self.areaDataStart = d3.svg.area()
          .x(function(d) { return x(d.label); })
          .y1(0).interpolate(self.chartOptions.lineStyle);

        // data for fill area, ending state
        self.areaData = d3.svg.area()
          .x(function(d) { return x(d.label); })
          .y1(function(d) { return -y(d.value); })
          .interpolate(self.chartOptions.lineStyle);

        // update path for fill area and lines
          if (self.chartOptions.animateStyle == "draw"){

            self.linePath 
              .data(data)
              .attr("d", self.line(data)); 

            if (self.chartOptions.fillArea){   
              self.areaPath
                .datum(data)
                  .attr("class", "data0 area")
                  .style("opacity", 0)
                  .attr("d", self.areaData);
            }
          } else {
          
            self.linePath
              .data(data)
              .attr("d", function(){ return self.chartOptions.fillArea ? self.line(data) : self.startingLine(data);})
              .attr("class", "data0 no-fill")
              .attr("stroke-width", "2.5")
              .attr("opacity", function(){ return self.chartOptions.fillArea ? 0 : 1;});

            if (self.chartOptions.fillArea){   
              self.areaPath 
                .datum(data)
                .attr("class", "area data0")
                .style("opacity", 0)
                .attr("d", self.areaDataStart)     
              }
          }
          
        self.circles
          .attr("cx", function(d) { return  x(d.label); })
          .attr("cy", function(d) { return -1 * y(d.value); });

        if (self.joystick){
          self.joystick.select('rect')
            .attr("height", height-36)
        }

        self.setStartingPosition();   
      },
      resize: function(){
        var self = this;
        self.dims = self.setupDimensions(self);
        self.width = self.dims.width;
        self.height = self.dims.height;

        // adjust the margins because labels and joystick need more space
        self.dims.margin.right = 10;
        self.dims.margin.left = 10;
        self.dims.margin.top = 30;
        self.dims.margin.bottom = 30;
        self.width = self.dims.width = Math.max(100,(self.chartWidth*0.95 -self.dims.margin.left - self.dims.margin.right));
      
        self._scaleBuilder();
        console.log("$$$$$$$$$$$$$$$$$");
        console.log(self.x(self.maxLabel));
        console.log(self.x(self.minLabel));
        self._setupElementSizes();
        if (self.chartOptions.joyStick) {
          self.moveJoystick();
        }
        self.animate();
        
      },
      updateData: function(){
        var self = this,
            data = self.chartData;
           
        self._scaleBuilder();

        var x = self.x,
            y = self.y;
        
        // select elements
        self.yLabels = self.g.selectAll('.yLabel').data(y.ticks(4));
        self.xLabels = self.g.selectAll('.xLabel').data(x.ticks(4));
        self.linePath = self.g.selectAll('path.data0').data(data);
        self.circles = self.g.selectAll('.circle').data(data);
        self.xAxis = self.g.selectAll('path.axis').data(data);

          
        // add new data points
        self.xLabels
          .enter().append("text")
          .attr("class", "xLabel axis")
          .text(function(d){ return d;})
          .attr("text-anchor", "middle")
          .attr("x", function(d) { return x(d) })
          .attr("y", self.dims.margin.top/2);
         
        self.yLabels  // these new ones are not being positioned correctly..
          .enter().append("text")
          .attr("class", "yLabel axis")
          .text(function(d){ return d;})
          .attr("dy", 4)
          .attr("opacity", function(d) { return self.chartOptions.animateAxis ? 0 : 1; })
          .style("text-anchor", "start");

        self.xAxis
          .attr("x1", x(self.minLabel))
          .attr("y1", 0)
          .attr("x2", x(self.maxLabel)) 
          .attr("y2", 0);

        console.log("**!*!*!*!*!");
        console.log(x(self.maxLabel));
        self.circles
          .enter().append("circle")
          .attr("class", "circle data0 stroke-foreground")
          .attr("r", function(){
            return self.chartOptions.joyStick ? 0 : 4;
          })
          .attr("stroke-width", 3);

         // remove extra datapoints
        self.linePath.exit().remove();

        self.circles.exit().remove();
        self.xLabels.exit().remove();
        self.yLabels.exit().remove();
        self.xAxis.exit().remove();
        self._setupElementSizes();
        if (self.chartOptions.joyStick) {
          self.moveJoystick();
        }
        self.animate();

        // select all the chart elements and set them in variables

        // redefine the linedata and areapaths
        // transition the paths to the new data

       
      },
      reset: function() {
        var self = this,
            g = self.g,
            svg = self.svg;
        
        // removes the lines, joystick and data/notes
        g.selectAll("path, circle, text").remove();     
        d3.select(self.$.info).selectAll("div, li").remove();  
        svg.selectAll(".joystick").remove();   
      },

      animate: function() {
        var self = this;
        self.animateAxis();
        self.animateLines();
        
        if (self.chartOptions.joyStick) {
          self.moveJoystick();
          self.showCurrentData(self.currentPos, firstTime=true);
        }
        
      },
      animateLines: function(){
        var self = this;
        var g = self.g, 
            svg = self.svg,
            data = self.chartData,
            x = self.x, 
            y = self.y,
            
            startingLine = self.startingLine,
            animationStyle = self.chartOptions.animateStyle; 
            
        if (animationStyle === "draw"){
            if (self.chartOptions.fillArea){
              // path for fill area

              self.areaPath
                // .transition()
                //   .duration(1000) 
                //   .ease("linear")
                //   .attr("stroke-dashoffset", 0)
                .style("opacity", 0.7); 
                  
            }

            // draw effect animation
            var totalLength = self.linePath.node().getTotalLength();

            self.linePath
              .attr("stroke-dasharray", totalLength + " " + totalLength)
              .attr("stroke-dashoffset", totalLength)
              .transition()
                .duration(1000) 
                .ease("linear")
                .attr("stroke-dashoffset", 0);

          } else { // raise style 
            if (self.chartOptions.fillArea){ 
              self.areaPath  
                // .datum(data)
                  .transition()
                  .duration(1000)
                  .ease("linear")
                  .attr("stroke-dashoffset", 0)
                .attr("d", self.areaData)
                .attr("opacity", 0.7);
            }

            // transition for ending state of line
            self.linePath
              .transition()
                .duration(function(){ return self.chartOptions.fillArea ? 5000 : 1000;})
                .attr("d", self.line(data))
                .attr("opacity", 1);

          }

          // If no joystick, format circles as same color as line, no stroke)
          if (!self.chartOptions.joyStick){
            self.circles
              .transition()
              .delay(1000)
              .duration(500)
              .attr('class', 'data0 circle')
              .attr('r', 4);
          }

            // // append circles to datapoints
            // g.selectAll(".circle")
            // .data(data)
            // .enter().append("circle")
            // .attr("class", "circle data0 stroke-foreground")
            // .attr("r", 0)
            // .attr("stroke-width", 3)
            // .attr("cx", function(d) { return  x(d.label); })
            // .attr("cy", function(d) { return -1 * y(d.value); })
      },
      animateAxis: function(){
        var self = this;
        if (self.chartOptions.animateAxis) {
          var yAxis = self.yAxis,
              y = self.y,
              maxValue = self.maxValue,
              yLabels = self.yLabels;

          yAxis.transition()
            .duration(1000)
            .attr("y1", -1 * 0)
            .attr("y2", -1 * y(maxValue))
            .attr("opacity", 1);

          yLabels.transition()
            .duration(1000)
            .attr("y", function(d) { return -1 * y(d) })
            .attr("opacity", 1);

        }
      },
      setStartingPosition: function(){
        var self = this,
            data = self.chartData;
        
        // FIND THE FIRST TOOLTIP AND SET AS CURRENT POSITION
        for (var i=0; i<data.length; i++){
          if (data[i].note){
            self.currentPos.label = data[i].label;
            self.currentPos.note = data[i].note;
            self.currentPos.value = data[i].display_value ? data[i].display_value : data[i].value;
            break;
          } else {
            self.currentPos.label = data[0].label;
            self.currentPos.note = data[0].note;
            self.currentPos.value = data[0].display_value ? data[0].display_value : data[0].value;
          }
        }
      },
      showCurrentData: function(currentPos, firstTime){
        var self = this,
            g = self.g,
            label = currentPos.closestLabel || currentPos.label,
            value = currentPos.val,
            note = currentPos.note;

            console.log("~~~~~~~~~~~~~~");
            console.log(label);
            console.log(currentPos);



          // show circles
          g.selectAll(".circle")
                .transition()
                .delay(function(){ return firstTime ? 1000 : 0})
                .duration(300)
                .attr("r", function(d){
                  console.log(d.label);
                  if ((parseInt(d.label)==parseInt(label))){ 
                    note = d.note;
                    value = d.display_value ? d.display_value : d.value;
                    return 4;
                  } else {
                    return 0;
                  }
                });

           // show note 
            self.note.transition() 
                .duration(100)      
                .style("opacity", 1);      
            self.note.html(note);  
            
            // show value
            self.displayValue.text(value);

      },
      moveJoystick: function(){
        var self = this, 
            svg = self.svg,
            x = self.x,
            w = self.width,
            h = self.height,
            g = self.g;

        // self.points = g.selectAll('.circle');
        self.currentPos.x = x(self.currentPos.label);  
        alert();
        if (!self.joystick){
          alert();
          self.joystick = svg.selectAll('g.joystick')
              .data([{x: self.currentPos.x}]) //??
              .enter()
                  .append('g')
                  .attr("class", "joystick")
                  .attr("height", 200)
                  .attr("width", w);

          var drag = d3.behavior.drag()
              .origin(Object)
              .on("drag", dragMove)
              .on('dragend', dragEnd);

          self.joystick.append("circle")
              .attr("class", "target")
              .attr("r", 8)
              .attr("cx", self.currentPos.x)
              .attr("cy", 12)
              .attr("class", "pulse fill-background stroke-foreground")
              .attr("stroke-width", 4.5)
              .call(drag);

          self.joystick.append('rect')
              .attr('y', 22)
              .attr('x', self.currentPos.x-1.5)
              .attr("height", h-36)
              .attr("width", 3)
              .attr("class", "fill-foreground")
              .attr('opacity', 0.4);

          self.lastPosX = self.joystick.select("circle").attr("cx");
        }

        function dragMove(d){
          var x = self.x;
            // move the circle
            d3.select(this)

              .attr("class", "fill-background stroke-foreground")
              .attr("cx", d.x = Math.max(self.dims.margin.left, Math.min(w, d3.event.x))); 
       
            // define current position
            self.currentPos.x = d3.select(this).attr("cx");
            console.log(self.currentPos.x);
            // move the line
            self.joystick.select('rect')
              .attr('x', self.currentPos.x-1)
              .attr('opacity', 1);

            // determine direction of slide movement
            if (self.currentPos.x < self.lastPosX){
              self.direction = "left";
              self.lastPosX = self.currentPos.x;
            } else {
              self.direction ="right";
              self.lastPosX = self.currentPos.x;
            }


            // determine which circles/notes are to be displayed
            g.selectAll(".circle")
              .attr("r", function(d){
                if ( Math.abs(x(d.label) - parseInt(self.currentPos.x)) < 10) {
                  self.currentPos.note = d.note;
                  self.currentPos.value = d.display_value ? d.display_value : d.value;
                  return 4;
                } else {
                  return 0;
                }
              });
           

            // Find the closest point to the joystick
            if (self.direction == "right"){
              self.currentPos.closestX = d3.min(self.circles[0], function(d){
                var cx = parseInt(d3.select(d).attr("cx"));                 
                return (cx - self.currentPos.x >= 0) ? cx : Number.MAX_VALUE  ;
              });
          
            } else {
              self.currentPos.closestX = d3.max(self.circles[0], function(d){
                var cx = parseInt(d3.select(d).attr("cx")); 
                return (cx - self.currentPos.x < 0) ? cx : Number.MIN_VALUE  ;
              });
            }
            
        }

        function dragEnd(){
         var x = self.x;
         // Lock the joystick in place
         console.log("#####");
         console.log(self.currentPos);
            d3.select(this)
              .attr('class','pulse')
              .transition()
                .duration(50)
                .attr('cx', self.currentPos.closestX);
            self.joystick.select('rect')
              .transition()
                .duration(50)
                .attr('x', self.currentPos.closestX-1) // adjusted bc of thickness of line
                .attr('opacity', 0.4);

            self.currentPos.closestLabel = x.invert(self.currentPos.closestX);
            self.showCurrentData(self.currentPos);

        
        }
      },
      chartSpecificDataValidate: function() {

        }
    });
  </script>

</polymer-element>
