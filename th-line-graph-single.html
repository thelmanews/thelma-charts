<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="th-d3-chart.html">

<polymer-element name="th-line-graph-single" extends="th-d3-chart">
  <template>
    <core-style ref="theme"> </core-style>
    <style>
      #chart {
        width: 100%;
        padding: 10px;
        box-sizing: border-box;
      }

      .xLabel, .yLabel {
        font-size: 0.6em;
        font-weight: 300;
      }

      circle {
        cursor: pointer;
      }

      @-webkit-keyframes pulse {  
        from {
         stroke: rgba(255, 255, 255, 0.9);
        }
        50% {
          stroke: rgba(255, 255, 255, 0.4);
        }
        to {
          stroke: rgba(255, 255, 255, 0.9);      
        }
      }

      .tooltip {
        width: 100%;
        position: relative;
        box-sizing: border-box;
        padding: 0px 20px;
      }

      .pulse {
        -webkit-animation-name: pulse;
        -webkit-animation-duration: 3s;
        -webkit-animation-iteration-count: infinite;
        animation-timing-function: linear;
      }
    </style>
    <svg id="chart"></svg> 
    <div id="info"></div> 
  </template> 
  
  <script>
    Polymer('th-line-graph-single', {
      chartOptions: {
        lineStyle: "cardinal", // options: linear, basis, cardinal, monotone, step-before/after
        animateStyle: "raise", // options: raise, draw
        animateAxis: false, // need to restyle the axis
        fillArea: true, 
        dataPosition: "left" // options: left, right
      
      },
      chartData: [
        {'label': 2010, 'value': 104,'display_value': '$104', 'tooltip': ''},
        {'label': 2011, 'value': 108,'display_value': '$108', 'tooltip': ''},
        {'label': 2012, 'value': 107,'display_value': '$107', 'tooltip': ''},
        {'label': 2013, 'value': 110,'display_value': '$110', 'tooltip': ''},
        {'label': 2014, 'value': 112,'display_value': '$112', 'tooltip': ''}
      ],
      init: function() {
        var self = this;

        // setup dimensions
        self.dims = self.setupDimensions(self);
        self.width = self.dims.width;
        self.height = self.dims.height;

        // adjust the margins because labels and joystick need more space
        self.dims.margin.right = 10;
        self.dims.margin.left = 10;
        self.dims.margin.top = 30;
        self.dims.margin.bottom = 30;
        self.width = self.dims.width = Math.max(100,(self.chartWidth*0.95 -self.dims.margin.left - self.dims.margin.right));
      
        self._scaleBuilder();
        self._setupElements();
        self._setupElementSizes();
        self.dataLength = self.chartData.length;
      },
      _scaleBuilder: function(){
        var self = this;

        self.maxLabel = self.getBoundaryValue(self, "label", d3.max);
        self.minLabel = self.getBoundaryValue(self, "label", d3.min);
        self.maxValue = self.getBoundaryValue(self, "value", d3.max);
        self.minValue = self.getBoundaryValue(self, "value", d3.min);
        
        self.y = d3.scale.linear().domain([self.minValue, self.maxValue]).range([self.dims.margin.top, 
                (self.height-(self.dims.margin.top + self.dims.margin.bottom)) ]), //30 to make room for the joystick
        self.x = d3.scale.linear().domain([self.minLabel, self.maxLabel]).range([0, self.width ]); 

      },
      _setupElements: function(){

        var self = this,
            width = self.width,
            height = self.height,
            y = self.y,
            x = self.x;
            g = self.g, 
            svg = self.svg,
            data = self.chartData,
            line = self.line,
            startingLine = self.startingLine,
            animationStyle = self.chartOptions.animateStyle; 



        self.currentPos = {};

        self.svg = d3.select(self.$.chart);
        
        var g = self.svg.append("g");
        self.g = g;

        self.tooltip = d3.select(self.$.info)
          .append("div")   
          .attr("class", "tooltip");

        // line data
        self.startingLine = d3.svg.line()
          .x(function(d) { return x(d.label); })
          .y(0).interpolate(self.chartOptions.lineStyle);

                self.line = d3.svg.line()
          .x(function(d) { return x(d.label); })
          .y(function(d) { return -y(d.value); })
          .interpolate(self.chartOptions.lineStyle);

     
        // x-axis
        self.xAxis = g.append("line")
          .attr("class", "axis")
          .attr("stroke-width", 2)
          .attr("x1", x(self.minLabel))
          .attr("y1", 0)
          .attr("x2", x(self.maxLabel)) 
          .attr("y2", 0);
        
        // y-axis
        self.yAxis = g.append("line")
          .attr("x1", 0)
          .attr("x2", 0)
          .attr("y1", function(d) { return self.chartOptions.animateAxis ? y(0) : -1 * y(self.minValue); }) 
          .attr("y2", function(d) { return self.chartOptions.animateAxis ? y(0) : -1 * y(self.maxValue); });
          // .attr("stroke-width", 2)
          // .attr("opacity", function(d) { return self.chartOptions.animateAxis ? 0 : 1; });

        // x labels
        g.selectAll(".xLabel")
          .data(x.ticks(5))// TODO: Replace with formula (number of labels)
          .enter().append("text")
          .attr("class", "xLabel axis")
          .text(String)
          .attr("x", function(d) { return x(d) })
          .attr("y", self.dims.margin.top/2)
          .attr("text-anchor", "middle");
          // .attr("fill", self.colors.foreground);
        
        // y labels
        self.yLabels = g.selectAll(".yLabel")
          .data(y.ticks(4)) // TODO: Replace with formula (number of labels)
          .enter().append("text")
          .attr("class", "yLabel axis")
          .text(String)
          .attr("transform", function(d){
            var yPos = self.chartOptions.animateAxis ? 0 : -1 * y(d);
            return "translate(0,"+ yPos +") rotate(-90)";
          } )
          .attr("dy", 4)
          // .attr("fill", self.colors.foreground)
          .attr("opacity", function(d) { return self.chartOptions.animateAxis ? 0 : 1; })
          .style("text-anchor", "start");

        // // x tick marks
        // g.selectAll(".xTicks")
        //   .data(x.ticks(5)) // TODO: Replace with formula (number of tickmarks)
        //   .enter().append("line")
        //   .attr("class", "xTicks")
        //   .attr("x1", function(d) { return x(d); })
        //   .attr("y1", -1 * y(0))
        //   .attr("x2", function(d) { return x(d); })
        //   .attr("y2", -1 * y(-0.5));
        //   // .attr("stroke", self.colors.foreground);
        
        // // y tick marks
        // self.yTicks = g.selectAll(".yTicks")
        //   .data(y.ticks(4)) // TODO: Replace with formula (number of tickmarks)
        //   .enter().append("line")
        //   .attr("class", "yTicks")
        //   .attr("y1", function(d) { return self.chartOptions.animateAxis ? 0 : -1 * y(d); })
        //   .attr("x1", 0)
        //   .attr("y2", function(d) { return self.chartOptions.animateAxis ? 0 : -1 * y(d); })
        //   .attr("x2", width)
        //   // .attr("stroke", self.colors.foreground)
        //   .attr("opacity", function(d) { return self.chartOptions.animateAxis ? 0 : 0.3; });
        
        self.displayValue = g.append('g').append('text')
          .attr("font-size", height/3)
          .attr("x", function(){
            return self.chartOptions.dataPosition === "left" ? self.dims.margin.left : (width-self.dims.margin.left);
           })
          .attr("text-anchor", function(){
            return self.chartOptions.dataPosition === "left" ? "start" : "end";
           })
          .attr("y", -(height/2))
          .attr("class", "fill-foreground")
          .attr("opacity", 0.7) // this can start as 0 and fade in after datapoint and joystick appear
          .text(self.currentPos.value);




        if (animationStyle === "draw"){
            if (self.chartOptions.fillArea){
              
              // data for fill area
              self.areaData = d3.svg.area()
                .x(function(d) { return x(d.label); })
                .y1(function(d) { return -y(d.value); })
                .interpolate(self.chartOptions.lineStyle);

              // path for fill area
              self.areaPath = g.append("path")
                .datum(data)
                .attr("class", "data0 area")
                .attr("opacity", 0)
                .attr("d", self.areaData);
            }

          self.linePath = g.selectAll('.data0').data(data)
              .enter().append("path")
              .attr("class", "data0 no-fill")
              .attr("stroke-width", "3")
              .attr("fill", "none");

          } else { // raise style 
            
            if (self.chartOptions.fillArea){ 
              
              // data for fill area, starting state
              self.areaDataStart = d3.svg.area()
                .x(function(d) { return x(d.label); })
                .y1(0).interpolate(self.chartOptions.lineStyle);
              
              // data for fill area, ending state
              self.areaData = d3.svg.area()
                .x(function(d) { return x(d.label); })
                .y1(function(d) { return -y(d.value); })
                .interpolate(self.chartOptions.lineStyle);

              // path for fill area
              self.areaPath = g.append("path")
                .datum(data)
                .attr("class", "area data0")
                .attr("opacity", 0)
                .attr("d", self.areaDataStart)

              // self.areaPath
            
                
            }

            // path for starting state of line
             self.linePath = g.selectAll('.data0').data(data).enter().append("path")
              .attr("d", function(){ return self.chartOptions.fillArea ? self.line(data) : self.startingLine(data);})
              .attr("class", "data0 no-fill")
              .attr("stroke-width", "2.5")
              .attr("fill", "none")
              .attr("opacity", function(){ return self.chartOptions.fillArea ? 0 : 1;});

            
          }

          // append circles to datapoints
          g.selectAll(".circle")
          .data(data)
          .enter().append("circle")
          .attr("class", "circle data0 stroke-foreground")
          .attr("r", 0)
          .attr("stroke-width", 3)
          .attr("cx", function(d) { return  x(d.label); })
          .attr("cy", function(d) { return -1 * y(d.value); })



      },
      _setupContainerSize: function(){
        var self = this,
            width = self.width,
            height = self.height;

        self.svg
          .attr("width", width)
          .attr("height", height); 

        self.g
          .attr("transform", "translate(0,"+ (height-self.dims.margin.top/2) +")");
   
      },
      _setupElementSizes: function(){
        var self = this,  
            width = self.width,
            height = self.height,
            y = self.y,
            x = self.x,
            data = self.chartData;

        self._setupContainerSize();
        
        // self.line = d3.svg.line()
        //   .x(function(d) { return x(d.label); })
        //   .y(function(d) { return -y(d.value); })
        //   .interpolate(self.chartOptions.lineStyle);

        // self.areaPath
        //   .datum(data);
          
        self.linePath
          .attr("d", self.line(data)); 

        self.setStartingPosition();   
      },
      resize: function(){
        var self = this;
        alert();
        self.dims = self.setupDimensions(self);
        self.width = self.dims.width;
        self.height = self.dims.height;

        // adjust the margins because labels and joystick need more space
        self.dims.margin.right = 10;
        self.dims.margin.left = 10;
        self.dims.margin.top = 30;
        self.dims.margin.bottom = 30;
        self.width = self.dims.width = Math.max(100,(self.chartWidth*0.95 -self.dims.margin.left - self.dims.margin.right));
      
        self._scaleBuilder();
        // self._setupElements();
        self._setupElementSizes();
        self.dataLength = self.chartData.length;
        self.animate();
        
      },
      updateData: function(){

       
      },
      reset: function() {
        var self = this,
            g = self.g,
            svg = self.svg;
        
        // removes the lines, joystick and data/tooltips
        g.selectAll("path, circle, text").remove();     
        d3.select(self.$.info).selectAll("div, li").remove();  
        svg.selectAll(".joystick").remove();   
      },

      animate: function() {
        var self = this;
        self.animateAxis();
        self.animateLines();
        self.moveJoystick();
        self.showCurrentData(self.currentPos, firstTime=true);
      },
      animateLines: function(){
        var self = this;
        var g = self.g, 
            svg = self.svg,
            data = self.chartData,
            x = self.x, 
            y = self.y,
            line = self.line,
            startingLine = self.startingLine,
            animationStyle = self.chartOptions.animateStyle; 
            
        if (animationStyle === "draw"){
            if (self.chartOptions.fillArea){
              // path for fill area
              self.areaPath
                .transition()
                  .duration(1000) 
                  .ease("linear")
                  .attr("stroke-dasharrayshoffset", 0)
                .attr("opacity", 0.7);
            }

            // draw effect animation
            var totalLength = self.linePath.node().getTotalLength();
            
            self.linePath
              .attr("stroke-dasharray", totalLength + " " + totalLength)
              .attr("stroke-dashoffset", totalLength)
              .transition()
                .duration(1000) 
                .ease("linear")
                .attr("stroke-dashoffset", 0);

          } else { // raise style 
            if (self.chartOptions.fillArea){ 
              self.areaPath  
                .datum(data)
                  .transition()
                  .duration(1000)
                  .ease("linear")
                  .attr("stroke-dashoffset", 0)
                .attr("d", self.areaData)
                .attr("opacity", 0.7);
            }

            // transition for ending state of line
            self.linePath
              .transition()
                .duration(function(){ return self.chartOptions.fillArea ? 5000 : 1000;})
                .attr("d", self.line(data))
                .attr("opacity", 1);

          }

          // append circles to datapoints
          g.selectAll(".circle")
          .data(data)
          .enter().append("circle")
          .attr("class", "circle data0 stroke-foreground")
          .attr("r", 0)
          .attr("stroke-width", 3)
          .attr("cx", function(d) { return  x(d.label); })
          .attr("cy", function(d) { return -1 * y(d.value); })
      },
      animateAxis: function(){
        var self = this;
        if (self.chartOptions.animateAxis) {
          var yAxis = self.yAxis,
              y = self.y,
              maxValue = self.maxValue,
              // yTicks = self.yTicks,
              yLabels = self.yLabels;

          yAxis.transition()
            .duration(1000)
            .attr("y1", -1 * 0)
            .attr("y2", -1 * y(maxValue))
            .attr("opacity", 1);

          yLabels.transition()
            .duration(1000)
            .attr("y", function(d) { return -1 * y(d) })
            .attr("opacity", 1);

          // yTicks.transition()
          //   .duration(1000)
          //   .attr("y1", function(d) { return -1 * y(d) })
          //   .attr("y2", function(d) { return -1 * y(d) })
          //   .attr("opacity", 1);
        }
      },
      setStartingPosition: function(){
        var self = this,
            data = self.chartData;
        
        // FIND THE FIRST TOOLTIP AND SET AS CURRENT POSITION
        for (var i=0; i<data.length; i++){
          if (data[i].tooltip){
            self.currentPos.label = data[i].label;
            self.currentPos.tooltip = data[i].tooltip;
            self.currentPos.value = data[i].display_value ? data[i].display_value : data[i].value;
            break;
          } else {
            self.currentPos.label = data[0].label;
            self.currentPos.tooltip = data[0].tooltip;
            self.currentPos.value = data[0].display_value ? data[0].display_value : data[0].value;
          }
        }
      },
      showCurrentData: function(currentPos, firstTime){
        var self = this,
            g = self.g,
            label = currentPos.closestLabel || currentPos.label,
            value = currentPos.val,
            tooltip = currentPos.tooltip;

          // show circles
          g.selectAll(".circle")
                .transition()
                .delay(function(){ return firstTime ? 1000 : 0})
                .duration(300)
                .attr("r", function(d){
                  if ((parseInt(d.label)==parseInt(label))){ 
                    tooltip = d.tooltip;
                    value = d.display_value ? d.display_value : d.value;
                    return 4;
                  } else {
                    return 0;
                  }
                });

           // show tooltip 
            self.tooltip.transition() 
                .duration(100)      
                .style("opacity", 1);      
            self.tooltip.html(tooltip);  
            
            // show value
            self.displayValue.text(value);

      },
      moveJoystick: function(){
        var self = this, 
            svg = self.svg,
            x = self.x,
            w = self.width,
            h = self.height,
            g = self.g;

        self.points = g.selectAll('.circle');
        self.currentPos.x = x(self.currentPos.label);  

        if (!joystick){
          var joystick = svg.selectAll('g.joystick')
              .data([{x: self.currentPos.x}]) //??
              .enter()
                  .append('g')
                  .attr("class", "joystick")
                  .attr("height", 200)
                  .attr("width", w);

          var drag = d3.behavior.drag()
              .origin(Object)
              .on("drag", dragMove)
              .on('dragend', dragEnd);

          joystick.append("circle")
              .attr("class", "target")
              .attr("r", 8)
              .attr("cx", self.currentPos.x)
              .attr("cy", 12)
              .attr("class", "pulse fill-background stroke-foreground")
              .attr("stroke-width", 4.5)
              .call(drag);

          joystick.append('rect')
              .attr('y', 22)
              .attr('x', self.currentPos.x-1.5)
              .attr("height", h-36)
              .attr("width", 3)
              .attr("class", "fill-foreground")
              .attr('opacity', 0.4);

          self.lastPosX = joystick.select("circle").attr("cx");
        }

        function dragMove(d){

            // move the circle
            d3.select(this)

              .attr("class", "fill-background stroke-foreground")
              .attr("cx", d.x = Math.max(0, Math.min(w, d3.event.x))); 
       
            // define current position
            self.currentPos.x = d3.select(this).attr("cx");

            // move the line
            joystick.select('rect')
              .attr('x', self.currentPos.x-1)
              .attr('opacity', 1);

            // determine direction of slide movement
            if (self.currentPos.x < self.lastPosX){
              self.direction = "left";
              self.lastPosX = self.currentPos.x;
            } else {
              self.direction ="right";
              self.lastPosX = self.currentPos.x;
            }


            // determine which circles/tooltips are to be displayed
            g.selectAll(".circle")
              .attr("r", function(d){
                if ( Math.abs(x(d.label) - parseInt(self.currentPos.x)) < 10) {
                  self.currentPos.tooltip = d.tooltip;
                  self.currentPos.value = d.display_value ? d.display_value : d.value;
                  return 4;
                } else {
                  return 0;
                }
              });
           

            // Find the closest point to the joystick
            if (self.direction == "right"){
              self.currentPos.closestX = d3.min(self.points[0], function(d){
                var cx = parseInt(d3.select(d).attr("cx"));                 
                return (cx - self.currentPos.x >= 0) ? cx : Number.MAX_VALUE  ;
              });
          
            } else {
              self.currentPos.closestX = d3.max(self.points[0], function(d){
                var cx = parseInt(d3.select(d).attr("cx")); 
                return (cx - self.currentPos.x < 0) ? cx : Number.MIN_VALUE  ;
              });
            }
        }

        function dragEnd(){
         // Lock the joystick in place
            d3.select(this)
              .attr('class','pulse')
              .transition()
                .duration(50)
                .attr('cx', self.currentPos.closestX);
            joystick.select('rect')
              .transition()
                .duration(50)
                .attr('x', self.currentPos.closestX-1) // adjusted bc of thickness of line
                .attr('opacity', 0.4);

            self.currentPos.closestLabel = x.invert(self.currentPos.closestX);
            self.showCurrentData(self.currentPos);

        
        }
      },
      chartSpecificDataValidate: function() {

        }
    });
  </script>

</polymer-element>
