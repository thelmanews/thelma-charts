<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="th-d3-chart.html">

<polymer-element name="th-line-graph-single" extends="th-d3-chart">
  <template>
    <core-style ref="theme"> </core-style>
    <style>
      #chart {
        width: 100%;
        padding: 10px;
        box-sizing: border-box;
      }

      .xLabel, .yLabel {
        font-size: 0.6em;
        font-weight: 300;
      }

      circle {
        cursor: pointer;
      }

      @-webkit-keyframes pulse {  
        from {
         stroke: rgba(255, 255, 255, 0.9);
        }
        50% {
          stroke: rgba(255, 255, 255, 0.4);
        }
        to {
          stroke: rgba(255, 255, 255, 0.9);      
        }
      }

      .note {
        width: 100%;
        position: relative;
        box-sizing: border-box;
        padding: 0px 20px;
      }

      .pulse {
        -webkit-animation-name: pulse;
        -webkit-animation-duration: 3s;
        -webkit-animation-iteration-count: infinite;
        animation-timing-function: linear;
      }

    </style>
    <svg id="chart"></svg> 
    <div id="info"></div> 
  </template> 
  
  <!-- this is for d3.tip, if used --> 
  <!-- <script src="http://labratrevenge.com/d3-tip/javascripts/d3.tip.v0.6.3.js"></script> -->

  <script>
       
    (function() { 

        var privateObj = {
           _scaleBuilder: function(polymerObj) {

              console.log(privateObj);

              privateObj.maxLabel = polymerObj.getBoundaryValue(polymerObj, "label", d3.max);
              privateObj.minLabel = polymerObj.getBoundaryValue(polymerObj, "label", d3.min);
              privateObj.maxValue = polymerObj.getBoundaryValue(polymerObj, "value", d3.max);
              privateObj.minValue = polymerObj.getBoundaryValue(polymerObj, "value", d3.min);
              
              privateObj.y = d3.scale.linear().domain([privateObj.minValue, privateObj.maxValue]).range([privateObj.dims.margin.top, 
                      (privateObj.height-(privateObj.dims.margin.top + privateObj.dims.margin.bottom)) ]), //30 to make room for the joystick

              privateObj.x = d3.scale.linear().domain([privateObj.minLabel, privateObj.maxLabel]).range([privateObj.dims.margin.left, privateObj.width ]); 

            },
            _setupElements: function(polymerObj){
              var width = privateObj.width,
                  height = privateObj.height,
                  y = privateObj.y,
                  x = privateObj.x;
                  g = privateObj.g, 
                  svg = privateObj.svg,
                  data = polymerObj.chartData,
                  line = privateObj.line,
                  startingLine = privateObj.startingLine,
                  animateStyle = polymerObj.chartOptions.animateStyle; 

              privateObj.currentPos = {};

              privateObj.svg = d3.select(polymerObj.$.chart);
              
              // container
              var g = privateObj.svg.append("g");
              privateObj.g = g;

              // note area
              privateObj.note = d3.select(polymerObj.$.info)
                .append("div")   
                .attr("class", "note");
           
              // x-axis
              privateObj.xAxis = g.append("line")
                .attr("class", "axis")
                .attr("stroke-width", 2)
                .attr("opacity", function(d) { return polymerObj.chartOptions.xAxisLine ? 1 : 0; });
               
              // y-axis
              privateObj.yAxis = g.append("line")
                .attr("x1", 0)
                .attr("x2", 0);       

              // x labels
              privateObj.xLabels = g.selectAll(".xLabel")
                .data(x.ticks(4))// TODO: Replace with formula (number of labels)
                .enter().append("text")
                .attr("class", "xLabel axis")
                .text(function(d){ return d;})
                .attr("opacity", function(d) { return polymerObj.chartOptions.xAxisLabels ? 1 : 0; })
                .attr("text-anchor", "middle");
              
              // y labels
              privateObj.yLabels = g.selectAll(".yLabel")
                .data(y.ticks(4)) // TODO: Replace with formula (number of labels)
                .enter().append("text")
                .attr("class", "yLabel axis")
                .text(function(d){ return d;})
                .attr("dy", 4)
                .attr("opacity", function(d) { return polymerObj.chartOptions.animateAxis || !polymerObj.chartOptions.yAxisLabels ? 0 : 1; })
                .style("text-anchor", "start");
              
              // large display value
              privateObj.displayValue = g.append('g').append('text')
                .attr("class", "fill-foreground")
                .attr("opacity", function(){
                  return polymerObj.chartOptions.joyStick ? 0.7 : 0;
                }); // this can start as 0 and fade in after datapoint and joystick appear

              // fill area path
              privateObj.areaPath = g.append("path");

              // line path
              privateObj.linePath = g.selectAll('.data0')
                  .data(data)
                  .enter().append("path")
                  .attr("class", "data0 no-fill")
                  .attr("stroke-width", "3")
                  .attr("fill", "none");

              // datapoints
              privateObj.circles = g.selectAll(".circle")
              .data(data)
              .enter().append("circle")
              .attr("class", "circle data0 stroke-foreground")
              .attr("r", 0);
              
              // tooltips
              privateObj.tips = g.selectAll('.tip')
                .data(data)
                .enter().append('text')
                .attr('class', 'tip label fill-foreground')
                .attr('text-anchor', 'middle');

            },
            _setupContainerSize: function(polymerObj){

              console.log(privateObj);

              privateObj.svg
                .attr("width", privateObj.width)
                .attr("height", privateObj.height); 

              console.log((privateObj.height-privateObj.dims.margin.top/2));
              privateObj.g
                .attr("transform", "translate(0,"+ (privateObj.height-privateObj.dims.margin.top/2) +")");

                console.log(privateObj.g.attr("transform"));
         
            },
            _setupElementSizes: function(polymerObj){
              var width = privateObj.width,
                  height = privateObj.height,
                  y = privateObj.y,
                  x = privateObj.x,
                  data = polymerObj.chartData,
                  valueSize = Math.min(width, height)/3; // this should adapt if width is narrow

              privateObj._setupContainerSize(polymerObj);
              
              privateObj.xAxis
                .attr("x1", x(privateObj.minLabel))
                .attr("y1", 0)
                .attr("x2", x(privateObj.maxLabel)) 
                .attr("y2", 0);

              privateObj.yAxis
                .attr("y1", function(d) { return polymerObj.chartOptions.animateAxis ? y(0) : -1 * y(privateObj.minValue); }) 
                .attr("y2", function(d) { return polymerObj.chartOptions.animateAxis ? y(0) : -1 * y(privateObj.maxValue); });
                // .attr("stroke-width", 2)
                // .attr("opacity", function(d) { return polymerObj.chartOptions.animateAxis ? 0 : 1; });

              privateObj.xLabels
                // .data(x.ticks(5))// TODO: Replace with formula (number of labels)
                .text(function(d){ return d;})
                .attr("x", function(d) { return x(d) })
                .attr("y", privateObj.dims.margin.top/2);

              privateObj.yLabels
                .text(function(d){ return d;})
                .attr("transform", function(d){
                  var yPos = polymerObj.chartOptions.animateAxis ? 0 : -1 * y(d);
                  return "translate(0,"+ yPos +") rotate(-90)";
                } );


              privateObj.displayValue
                .attr("text-anchor", function(){ return polymerObj.chartOptions.dataPosition === "left" ? "start" : "end"; })
                .attr("x", function(){ return polymerObj.chartOptions.dataPosition === "left" ? privateObj.dims.margin.left : (width-privateObj.dims.margin.left); })
                .attr("y", -(height - valueSize - privateObj.dims.margin.top)) 
                .attr("font-size", valueSize) 
                .text(privateObj.currentPos.value);

              
              // line data, starting state (raise)
              privateObj.startingLine = d3.svg.line()
                .x(function(d) { return x(d.label); })
                .y(0).interpolate(polymerObj.chartOptions.lineStyle);

              // line data, ending state
              privateObj.line = d3.svg.line()
                .x(function(d) { return x(d.label); })
                .y(function(d) { return -y(d.value); })
                .interpolate(polymerObj.chartOptions.lineStyle);

              // data for fill area, starting state (raise)
              privateObj.areaDataStart = d3.svg.area()
                .x(function(d) { return x(d.label); })
                .y1(0).interpolate(polymerObj.chartOptions.lineStyle);

              // data for fill area, ending state
              privateObj.areaData = d3.svg.area()
                .x(function(d) { return x(d.label); })
                .y1(function(d) { return -y(d.value); })
                .interpolate(polymerObj.chartOptions.lineStyle);

              // update path for fill area and lines
                if (polymerObj.chartOptions.animateStyle == "draw"){

                  privateObj.linePath 
                    .data(data)
                    .attr("d", privateObj.line(data)); 

                  if (polymerObj.chartOptions.fillArea){   
                    privateObj.areaPath
                      .datum(data)
                        .attr("class", "data0 area")
                        .attr("opacity", 0)
                        .attr("d", privateObj.areaData);
                  }
                } else {
                
                  privateObj.linePath
                    .data(data)
                    .attr("d", function(){ return polymerObj.chartOptions.fillArea ? privateObj.line(data) : privateObj.startingLine(data);})
                    .attr("class", "data0 no-fill")
                    .attr("stroke-width", "2.5")
                    .attr("opacity", function(){ return polymerObj.chartOptions.fillArea ? 0 : 1;});

                  if (polymerObj.chartOptions.fillArea){   
                    privateObj.areaPath 
                      .datum(data)
                      .attr("class", "area data0")
                      .attr("opacity", 0)
                      .attr("d", privateObj.areaDataStart)     
                    }
                }
                
              privateObj.circles
                .attr("stroke-width", 3)
                .attr("cx", function(d) { return  x(d.label); })
                .attr("cy", function(d) { return -1 * y(d.value); });

              if (privateObj.joystick){
                privateObj.joystick.select('rect')
                  .attr("height", height-36)
              }

              polymerObj.setStartingPosition();   
            }
        };
        //end private obj


        Polymer('th-line-graph-single', {
          chartOptions: {
            lineStyle: "cardinal", // options: linear, basis, cardinal, monotone, step-before/after
            animateStyle: "draw", // options: raise, draw
            fillArea: false, 
            xAxisLine: true,
            xAxisLabels: true,
            yAxisLine: false, // doesnt do anything, there is never a line
            yAxisLabels: false,
            animateAxis: false, // need to restyle the axis
            dataPosition: "left",  // options: left, right
            joyStick: true 
          },
          chartData: [
            {'label': 2010, 'value': 104,'display_value': '$104', 'note': ''},
            {'label': 2011, 'value': 108,'display_value': '$108', 'note': ''},
            {'label': 2012, 'value': 107,'display_value': '$107', 'note': ''},
            {'label': 2013, 'value': 110,'display_value': '$110', 'note': ''},
            {'label': 2014, 'value': 112,'display_value': '$112', 'note': ''}
          ],
          init: function() {
            var self = this;

            // setup dimensions
            privateObj.dims = self.setupDimensions(self);
            console.log(privateObj.dims);


            privateObj.width = privateObj.dims.width;
            privateObj.height = privateObj.dims.height;     //NEEDED?!?

            console.log(privateObj);

            // adjust the margins because labels and joystick need more space
            privateObj.dims.margin.right = 10;
            privateObj.dims.margin.left = 15;
            privateObj.dims.margin.top = 30;
            privateObj.dims.margin.bottom = 30;
            privateObj.width = privateObj.dims.width = Math.max(100,(self.chartWidth*0.95 -privateObj.dims.margin.left - privateObj.dims.margin.right));

            //NEEDED ?!?
          
            privateObj._scaleBuilder(self);
            privateObj._setupElements(self);
            privateObj._setupElementSizes(self); 
            privateObj.dataLength = self.chartData.length;
          },
          
          resize: function(){
            var self = this;
            privateObj.dims = self.setupDimensions(self);
            privateObj.width = privateObj.dims.width;
            privateObj.height = privateObj.dims.height;

            // adjust the margins because labels and joystick need more space
            privateObj.dims.margin.right = 10;
            privateObj.dims.margin.left = 15;
            privateObj.dims.margin.top = 30;
            privateObj.dims.margin.bottom = 30;
            privateObj.width = privateObj.dims.width = Math.max(100,(self.chartWidth*0.95 -privateObj.dims.margin.left - privateObj.dims.margin.right));
          
            privateObj._scaleBuilder(self);
            privateObj._setupElementSizes(self);

            if (self.chartOptions.joyStick) {
              self.moveJoystick();
            } else {
              self.showTooltips();
            }

            self.animate();
            
          },
          updateData: function(){
            var self = this,
                data = self.chartData;
               
            privateObj._scaleBuilder(self);

            var x = privateObj.x,
                y = privateObj.y;
            
            // select elements
            privateObj.yLabels = privateObj.g.selectAll('.yLabel').data(y.ticks(4));
            privateObj.xLabels = privateObj.g.selectAll('.xLabel').data(x.ticks(4));
            privateObj.linePath = privateObj.g.selectAll('path.data0').data(data);
            privateObj.circles = privateObj.g.selectAll('.circle').data(data);
            privateObj.xAxis = privateObj.g.selectAll('path.axis').data(data);
            privateObj.tips = privateObj.g.selectAll('.tip').data(data);
            // self.areaPath = self.g.selectAll('.area').datum(data);
              
              
            // add new data points
            privateObj.xLabels
              .enter().append("text")
              .attr("class", "xLabel axis")
              .text(function(d){ return d;})
              .attr("text-anchor", "middle")
              .attr("x", function(d) { return x(d) })
              .attr("y", privateObj.dims.margin.top/2);
             
            privateObj.yLabels  // these new ones are not being positioned correctly..
              .enter().append("text")
              .attr("class", "yLabel axis")
              .text(function(d){ return d;})
              .attr("dy", 4)
              .attr("opacity", function(d) { return self.chartOptions.animateAxis ? 0 : 1; })
              .style("text-anchor", "start");

            privateObj.xAxis
              .attr("x1", x(privateObj.minLabel))
              .attr("y1", 0)
              .attr("x2", x(privateObj.maxLabel)) 
              .attr("y2", 0);

            privateObj.circles
              .enter().append("circle")
              .attr("class", "circle data0 stroke-foreground")
              .attr("r", function(){
                return self.chartOptions.joyStick ? 0 : 4;
              })
              .attr("r", 0);

            privateObj.tips
              .enter().append('text')
              .attr('class', 'tip label fill-foreground')
              .attr('text-anchor', 'middle');

             // remove extra datapoints
            privateObj.linePath.exit().remove();
            privateObj.circles.exit().remove();
            privateObj.xLabels.exit().remove();
            privateObj.yLabels.exit().remove();
            privateObj.xAxis.exit().remove();
            privateObj.tips.exit().remove();
            privateObj._setupElementSizes(self);
            
            if (self.chartOptions.joyStick) {
              self.moveJoystick();
            } else {
              self.showTooltips();
            }
            self.animate();
           
          },
          reset: function() {
            var self = this,
                g = privateObj.g,
                svg = privateObj.svg;
      
            // removes the lines, joystick and data/notes
            g.selectAll("path, circle, text, rect, line").remove();     
            d3.select(self.$.info).selectAll("div, li").remove();  
            svg.selectAll('g.joyStick').remove();
            privateObj._setupElements(self);
            privateObj._setupElementSizes(self); 
            
          },

          animate: function() {
            var self = this;
            self.animateAxis();
            self.animateLines();
            
            if (self.chartOptions.joyStick) {
              self.moveJoystick();
              self.showCurrentData(privateObj.currentPos, firstTime=true);
            } else {
              self.showTooltips();
            }
            
          },
          animateLines: function(){
            var self = this;
            var g = privateObj.g, 
                svg = privateObj.svg,
                data = self.chartData,
                x = privateObj.x, 
                y = privateObj.y,
                
                startingLine = privateObj.startingLine,
                animateStyle = self.chartOptions.animateStyle; 
                
            if (animateStyle === "draw"){
                if (self.chartOptions.fillArea){
                  // path for fill area

                  privateObj.areaPath
                    // .transition()
                    //   .duration(1000) 
                    //   .ease("linear")
                    //   .attr("stroke-dashoffset", 0)
                    .style("opacity", 0.7); 
                      
                }

                // draw effect animation
                var totalLength = privateObj.linePath.node().getTotalLength();

                privateObj.linePath
                  .attr("stroke-dasharray", totalLength + " " + totalLength)
                  .attr("stroke-dashoffset", totalLength)
                  .transition()
                    .duration(1000) 
                    .ease("linear")
                    .attr("stroke-dashoffset", 0);

              } else { // raise style 
                if (self.chartOptions.fillArea){ 
                  privateObj.areaPath  
                    // .datum(data)
                      .transition()
                      .duration(1000)
                      .ease("linear")
                      .attr("stroke-dashoffset", 0)
                    .attr("d", privateObj.areaData)
                    .attr("opacity", 0.7);
                }

                // transition for ending state of line
                privateObj.linePath
                  .transition()
                    .duration(function(){ return self.chartOptions.fillArea ? 5000 : 1000;})
                    .attr("d", privateObj.line(data))
                    .attr("opacity", 1);

              }

              // If no joystick, format circles as same color as line, no stroke)
              if (!self.chartOptions.joyStick){
                privateObj.circles
                  .transition()
                  .delay(1000)
                  .duration(500)
                  .attr('class', 'data0 circle')
                  .attr('r', 4);
              }

                // // append circles to datapoints
                // g.selectAll(".circle")
                // .data(data)
                // .enter().append("circle")
                // .attr("class", "circle data0 stroke-foreground")
                // .attr("r", 0)
                // .attr("stroke-width", 3)
                // .attr("cx", function(d) { return  x(d.label); })
                // .attr("cy", function(d) { return -1 * y(d.value); })
          },
          animateAxis: function(){
            var self = this;
            if (self.chartOptions.animateAxis) {
              var yAxis = privateObj.yAxis,
                  y = privateObj.y,
                  maxValue = privateObj.maxValue,
                  yLabels = privateObj.yLabels;

              yAxis.transition()
                .duration(1000)
                .attr("y1", -1 * 0)
                .attr("y2", -1 * y(maxValue))
                .attr("opacity", 1);

              yLabels.transition()
                .duration(1000)
                .attr("y", function(d) { return -1 * y(d) })
                .attr("opacity", 1);

            }
          },
          setStartingPosition: function(){
            var self = this,
                data = self.chartData;
            
            // FIND THE FIRST TOOLTIP AND SET AS CURRENT POSITION
            for (var i=0; i<data.length; i++){
              if (data[i].note){
                privateObj.currentPos.label = data[i].label;
                privateObj.currentPos.note = data[i].note;
                privateObj.currentPos.value = data[i].display_value ? data[i].display_value : data[i].value;
                break;
              } else {
                privateObj.currentPos.label = data[0].label;
                privateObj.currentPos.note = data[0].note;
                privateObj.currentPos.value = data[0].display_value ? data[0].display_value : data[0].value;
              }
            }
          },
          showCurrentData: function(currentPos, firstTime){
            var self = this,
                g = privateObj.g,
                label = currentPos.closestLabel || currentPos.label,
                value = currentPos.val,
                note = currentPos.note;

              // show circles
              g.selectAll(".circle")
                    .transition()
                    .delay(function(){ return firstTime ? 1000 : 0})
                    .duration(300)
                    .attr("r", function(d){
                     
                      if ((parseInt(d.label)==parseInt(label))){ 
                        note = d.note;
                        value = d.display_value ? d.display_value : d.value;
                        return 4;
                      } else {
                        return 0;
                      }
                    });

               // show note 
                privateObj.note.transition() 
                    .duration(100)      
                    .style("opacity", 1);      
                privateObj.note.html(note);  
                
                // show value
                privateObj.displayValue.text(value);

          },
          moveJoystick: function(){
            var self = this, 
                svg = privateObj.svg,
                x = privateObj.x,
                w = privateObj.width,
                h = privateObj.height,
                g = privateObj.g;

            privateObj.currentPos.x = x(privateObj.currentPos.label);  
            
            if (!privateObj.joystick){
            
              privateObj.joystick = svg.selectAll('g.joystick')
                  .data([{x: privateObj.currentPos.x}]) //??
                  .enter()
                      .append('g')
                      .attr("class", "joystick")
                      // .attr("height", 200)
                      .attr("width", w);

              var drag = d3.behavior.drag()
                  .origin(Object)
                  .on("drag", dragMove)
                  .on('dragend', dragEnd);

              privateObj.joystick.append("circle")
                  .attr("class", "target")
                  .attr("r", 8)
                  .attr("cx", privateObj.currentPos.x)
                  .attr("cy", 12)
                  .attr("class", "pulse fill-background stroke-foreground")
                  .attr("stroke-width", 4.5)
                  .call(drag);

              privateObj.joystick.append('rect')
                  .attr('y', 22)
                  .attr('x', privateObj.currentPos.x-1.5)
                  .attr("height", h-36)
                  .attr("width", 3)
                  .attr("class", "fill-foreground")
                  .attr('opacity', 0.4);

              privateObj.lastPosX = privateObj.joystick.select("circle").attr("cx");
            }

            function dragMove(d){
              var x = privateObj.x;
                // move the circle
                d3.select(this)

                  .attr("class", "fill-background stroke-foreground")
                  .attr("cx", d.x = Math.max(privateObj.dims.margin.left, Math.min(privateObj.width, d3.event.x))); 
           
                // define current position
                privateObj.currentPos.x = d3.select(this).attr("cx");
                // move the line
                privateObj.joystick.select('rect')
                  .attr('x', privateObj.currentPos.x-1)
                  .attr('opacity', 1);

                // determine direction of slide movement
                if (privateObj.currentPos.x < privateObj.lastPosX){
                  privateObj.direction = "left";
                  privateObj.lastPosX = privateObj.currentPos.x;
                } else {
                  privateObj.direction ="right";
                  privateObj.lastPosX = privateObj.currentPos.x;
                }

                // determine which circles/notes are to be displayed
                g.selectAll(".circle")
                  .attr("r", function(d){
                    if ( Math.abs(x(d.label) - parseInt(privateObj.currentPos.x)) < 10) {
                      privateObj.currentPos.note = d.note;
                      privateObj.currentPos.value = d.display_value ? d.display_value : d.value;
                      return 4;
                    } else {
                      return 0;
                    }
                  });
               

                // Find the closest point to the joystick
                if (privateObj.direction == "right"){
                  privateObj.currentPos.closestX = d3.min(privateObj.circles[0], function(d){
                    var cx = parseInt(d3.select(d).attr("cx"));                 
                    return (cx - privateObj.currentPos.x >= 0) ? cx : Number.MAX_VALUE  ;
                  });
              
                } else {
                  privateObj.currentPos.closestX = d3.max(privateObj.circles[0], function(d){
                    var cx = parseInt(d3.select(d).attr("cx")); 
                    return (cx - privateObj.currentPos.x < 0) ? cx : Number.MIN_VALUE  ;
                  });
                }
                
            }

            function dragEnd(){
             var x = privateObj.x;
             // Lock the joystick in place
            
                d3.select(this)
                  .attr('class','pulse')
                  .transition()
                    .duration(50)
                    .attr('cx', privateObj.currentPos.closestX);
                privateObj.joystick.select('rect')
                  .transition()
                    .duration(50)
                    .attr('x', privateObj.currentPos.closestX-1) // adjusted bc of thickness of line
                    .attr('opacity', 0.4);

                // Rounding the below number is a temp fix - because x.invert is resulting in a decimal number.
                privateObj.currentPos.closestLabel = Math.round(x.invert(privateObj.currentPos.closestX));
                self.showCurrentData(privateObj.currentPos);

            
            }
          },
          showTooltips: function(){
            var self = this,
                g = privateObj.g,
                data = self.chartData,
                x = privateObj.x,
                y = privateObj.y;

            privateObj.tips          
              .text( function(d){return d.display_value; })
              .attr("x", function(d) { return  x(d.label); })
              .attr("y", function(d) { return -y(d.value) - 15; })
              .attr('opacity', 0)
              .transition()
              .delay(1000)
              .duration(500)
              .attr('opacity', 1);

            // USES D3.TIP LIBRARY - appends tips to body and loses styling
            // privateObj.tip = d3.tip()
            //     .attr('class', 'd3-tip label fill-foreground')
            //     .offset([-10, 0])
            //     .html(function(d) {
            //       return d.display_value;
            //     });

            // g.call(privateObj.tip);
              
            // privateObj.circles
            // .on('mouseover', privateObj.tip.show) // how to call tip.show w/out on mouse event?
            // .on('mouseout', self.tip.hide);


          },
          chartSpecificDataValidate: function() {

            }
        });

    })();

  </script>

</polymer-element>
