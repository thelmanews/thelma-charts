<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="th-d3-chart.html">

<polymer-element name="th-n-bar-chart" extends="th-d3-chart">

	<script>

    (function() {


      //  static private methods and private attributes ...
      var privateObj = {};

      // adding methods from mixin object to privateObj
      Thelma.BarFamilyPrivateStaticMethods.apply(privateObj);

      
      // Adding private static methods.

      privateObj._setElementSizes = function(self) {


	    	  var margin = privateObj.dims.margin,
		    	  width = privateObj.dims.width,
		    	  height = privateObj.dims.height,
		    	  x = privateObj.x,
		    	  y = privateObj.y;

		      privateObj._setupContainerSize(self);


		      
		      privateObj.bars
		        .attr("class", function(d,i){return "bar data"+i;});

		      
		      privateObj.labels
		        .attr("class", function(d,i){return "label data"+i;});
		        //.style('opacity', 0)

		      
		      privateObj.values
		        .attr("class", function(d,i){return "value data"+i;})
		        .attr('text-anchor','middle')
		        //.style('opacity', 0)
		        //.attr('x', function(d) { return x(i) + privateObj.dims.bars.width/2; })
		        .attr('font-size', privateObj.dims.values.size+"px");
		       // .attr('y', height)
		       // .style('opacity', 0);

		};

		 privateObj._setupElements = function(self) {
		      
		      privateObj.svg = d3.select(self.$.chart);

		      privateObj.container = privateObj.svg
		          .selectAll('.container')
		          .data([1])
		          .enter()
		          .append('g')
		          .attr('class','container');

		      privateObj.bars = privateObj.container.selectAll('.bar').data(self.chartData).enter().append('rect').attr('class','bar')
		      .attr('height', 0)
		      .attr('y', privateObj.dims.height);

		      privateObj.labels = privateObj.container.selectAll('.label').data(self.chartData).enter().append('text').attr('class','label')
		      .attr('text-anchor',function(){ 
		        	return privateObj.dims.labels.angle > 0 ? "left" : "middle";
		        	
		        })
		        .attr('transform', function(d,i){
			        	var xPos = privateObj.x(i) + privateObj.dims.bars.width/2 ;
			        	var yPos = privateObj.dims.height + privateObj.dims.margin.label;
			        	var rotation = privateObj.dims.labels.angle;

			        	//if there is an angle, move labels slightly to top left
			        	if(rotation> 0) {
			        		xPos = xPos -7;
			        		yPos = yPos -3;
			        	}
			        	return "translate("+xPos+","+yPos+") rotate("+ rotation +")"
			    });

		      privateObj.values = privateObj.container.selectAll('.value').data(self.chartData).enter().append('text').attr('class','value')
		      .attr('y', privateObj.dims.height)
		      .style('opacity', 0);

		  };



		  privateObj._setupContainerSize = function(self) {
		  	  
		  	  var margin = privateObj.dims.margin,
		    	  width = privateObj.dims.width,
		    	  height = privateObj.dims.height;


		  	  privateObj.svg
		      	.attr('width', width + margin.left + margin.right)
		        .attr('height', height + margin.top + margin.bottom);

		      // setting up the size. needed for resizing
		      privateObj.container.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

		  };

		// POLYMER OBJECT DEF.


		Polymer('th-n-bar-chart', {
		  chartData: [
		    {label: 'Player', value: 15, display_value: '$15'},
		    {label: 'Vendor', value: 20, display_value: '$20'},
		    {label: 'Mascot', value: 45, display_value: '$45'}
		  ],
		  init: function() {
		    
		  	  var self = this;
		  	  
		  	  privateObj.dims = self.setupDimensions(self);

		      privateObj.dims = privateObj.setupBarLabelDims(privateObj.dims, self.chartData, 1, 1.3);

	    	  var margin = privateObj.dims.margin,
	    	  	  width = privateObj.dims.width,
	    	      height = privateObj.dims.height;


		      privateObj.dataLength = self.chartData.length;




		      // creating scales
		      var scales = self.simpleScaleBuilder(width, height, self.chartData);

		      var x = scales.x;
		      var y = scales.y;

		      privateObj.y = y;
		      privateObj.x = x;

		      privateObj._setupElements(self);

		      //setting sizes
		      privateObj._setElementSizes(self);

		      // this is independent of size but dependent on data
		      privateObj.labels.text(function(d) {return d.label;});
		      privateObj.values.text(function(d) {return d.display_value ? d.display_value : d.value ;});

		        
		  },


		  reset: function(hard) {
		      
		      var height= privateObj.dims.height;
		      // without transition
		      if(hard) {
			      privateObj.bars.attr('y', height).attr('height', 0);
			      privateObj.values.attr('y', height );
			  }
			  else {
			      privateObj.bars.transition().duration(1000).attr('y', height).attr('height', 0).style('opacity', 0);
			      privateObj.values.transition().duration(1000).attr('y', height ).style('opacity', 0);

			  }
		      
		  },
		  
		  animate: function() {

		  		var self = this;

		        var y = privateObj.y;
		        var height= privateObj.dims.height;
		        privateObj.bars.transition().duration(this.animationDelay)
		        .attr('x', function(d, i) { return privateObj.x(i); })
		        .attr('y', function(d) { return height-y(d.value);})
		        .attr('width', privateObj.dims.bars.width)
		        .attr('height', function(d) {return y(d.value)})
		        .style('opacity', 1);
		        
		        privateObj.values.transition(this.animationDelay).duration(this.animationDelay)
		        //.style('opacity', 1)
		        .attr('x', function(d,i) { return privateObj.x(i) + privateObj.dims.bars.width/2; })
		        .attr('y', function(d) {return height - y(d.value) - privateObj.dims.values.margin;})
		        .style('opacity', 1);

		        privateObj.labels.transition(this.animationDelay).duration(this.animationDelay)
		        .attr('text-anchor',function(){ 
		        	return privateObj.dims.labels.angle > 0 ? "left" : "middle";
		        	
		        })
		        .attr('transform', function(d,i){
			        	var xPos = privateObj.x(i) + privateObj.dims.bars.width/2 ;
			        	var yPos = height + privateObj.dims.margin.label;
			        	var rotation = privateObj.dims.labels.angle;

			        	//if there is an angle, move labels slightly to top left
			        	if(rotation> 0) {
			        		xPos = xPos -7;
			        		yPos = yPos -3;
			        	}
			        	return "translate("+xPos+","+yPos+") rotate("+ rotation +")"
			    });

		  },

		  resize: function() {
		  	  
		  	  var self = this;
		  	  
		  	  privateObj.dims = self.setupDimensions(self);

		  	  // self.setupExtraDimensions();


		  	  privateObj._setupContainerSize(self); // correct size if margins are changed (by setting the label diagonal)



	    	  var margin = privateObj.dims.margin,
	    	  	  width = privateObj.dims.width,
	    	      height = privateObj.dims.height;

	    	  var scales = self.simpleScaleBuilder(width, height, self.chartData);

		      var x = scales.x;
		      var y = scales.y;
		      

		      privateObj.y = y;
		      privateObj.x = x;

		      //setting sizes
		      // self.setupBarDims(self, 1, 1.3); // self, overlap, gap
		      // self.setupLabelDims(self);
		      // self.setupValueDims(self);

		      privateObj.dims = privateObj.setupBarLabelDims(privateObj.dims, self.chartData, 1, 1.3);


		      privateObj._setElementSizes(self);

		      self.animate();


		  },

		  updateData: function() {


		  	  var self = this;

		      
		      var scales = self.simpleScaleBuilder(privateObj.dims.width, privateObj.dims.height, self.chartData);


		      var x = scales.x;
		      var y = scales.y;

		      // is there a better way than exposing these?!
		      privateObj.y = y;
		      privateObj.x = x;

		      var width = privateObj.dims.width,
		      	 height = privateObj.dims.height;	  	  

			  privateObj.bars = privateObj.container.selectAll('.bar').data(self.chartData);
			  privateObj.labels = privateObj.container.selectAll('.label').data(self.chartData);
			  privateObj.values=privateObj.container.selectAll('.value').data(self.chartData);

		  	  if(privateObj.dataLength!=self.chartData.length)
		  	  {


		  	  	  privateObj.dataLength = self.chartData.length;

				  privateObj.dims.barWidth = Math.min(70,((privateObj.dims.width / privateObj.dataLength)/(1+privateObj.dims.barGap)));

				  // self.setupExtraDimensions();


				  privateObj._setupContainerSize(self); // correct size if margins are changed (by setting the label diagonal)

			      privateObj.bars.enter().append('rect').attr('class','bar')
			      	.attr('height', 0)
			      	.attr('y', height)
			      	.attr('width', 0)
			      	.style('opacity', 0)
			      	.attr('x', function(d) {
			      		return width;
			      	});
			      privateObj.labels.enter().append('text').attr('class','label');
			      privateObj.values.enter().append('text').attr('class','value').attr('y', height);


			      privateObj.bars.exit().transition().duration(1000).attr('height', 0).attr('y', height).attr('x', width).style('opacity', 0).remove();
			      privateObj.labels.exit().transition().duration(1000).style('opacity', 0).remove();
			      privateObj.values.exit().transition().duration(1000).style('opacity', 0).remove();
			      





			     self.resize();

			    }

		      // this is independent of size but dependent on data
		      privateObj.labels.text(function(d) {return d.label;});
		      privateObj.values.text(function(d) {return d.display_value ? d.display_value : d.value ;});


		      self.animate();
		      

		  },

		  chartSpecificDataValidate: function() {
	    
		      var errors = [],
		          numOfBars = this.chartData.length;

		      // There should be at least value.
		      if(numOfBars === 0) {
		        errors.push({input: numOfBars, msg: 'Please provide at least one value for the chart.'});
		      } else {
		        for (var i=0; i < numOfBars; i++){
		          
		          // There should be a value for every bar.
		        	if (!this.chartData[i].value){ 
		          	errors.push({ input: this.chartData, msg: 'You must include a value for every bar.'});
		        	}
		          
		          // There should be a label for every bar.
		        	if (!this.chartData[i].label){ 
		          	errors.push({ input: this.chartData, msg: 'You must include a label for every bar.'});
		        	}
		        }
		      }

	          return errors;
	       }

	      


		  
		});

	})();


	</script>
</polymer-element>
