<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="th-d3-chart.html">

<polymer-element name="th-timeline" extends="th-d3-chart">
  <template>   
    <core-style ref="theme"> </core-style>
    <style>
      .current {

      }

      .headline-text {

      }

      .body-text {

      }

      .detail-text {

      }

      .label-text {
        font-size: 0.8em;
      }

      .label-details {
        font-size: 0.6em;
      }
      .event-info {
        background-color: red;
        position: absolute;
        z-index: 20;
        font-size: 20px;
        color: yellow;
      }

    </style>
    
    <svg id="chart"></svg> 
  </template> 
  
  <script>

    Polymer('th-timeline', {
      chartData: [
        {date: '1', headline: 'July 15', body:"Egypt proposed a ceasefire. Israel accepted, Hamas hadn't been part of discussions and continued fighting.", detail: '', image: '', fill:'', startHere: true},
        {date: '2', headline: 'July 17', body:"UN asked for a five-hour ceasefire for humanitarian reasons.  Fighting resumed soon afterwards.", detail: '', image: '', fill:'', startHere: false},
        {date: '3', headline: 'July 20', body:"Red Cross tried a two-hour ceasefire in one area of Gaza. It didn't hold.", detail: '', image: '', fill:'', startHere: false},
        {date: '4', headline: 'July 25', body:"John Kerry calls for a week-long truce for talks to be held. Israel refuses.", detail: '', image: '', fill:'', startHere: false},
        {date: '5', headline: 'July 26 - 28', body:"A 12-hour humanitarian ceasefire is extended during the Muslim festival of Eid.", detail: '', image: '', fill:'', startHere: false},
        {date: '6', headline: 'July 31', body:"A three-day ceasefire announced by the UN and John Kerry lasts only a few hours.", detail: '', image: '', fill:'', startHere: false},
        {date: '7', headline: 'August 4', body:"Israel declares a seven-hour humanitarian ceasefire. It doesn't last.", detail: 'Morning', image: '', fill:'', startHere: false},
        {date: '8', headline: 'August 4', body:"Israel and Hamas agree to a 72-hour ceasefire. It is currently holding.", detail: 'Evening', image: '', fill:'', startHere: false}
      ],
      scale: "time", // or 'linear' if no dates
      startDate: '0',
      endDate: '10',
      theme: 'light',
      init: function() {
        var self = this,
            data = self.chartData;

        // setup dimensions
        self.dims = self.setupDimensions(self);
        
         
        // setup scale
        self.yScale = d3.time.scale()
          .domain([self.startDate, self.endDate])
          .range([0, self.chartHeight]);


        // set starting point
        self.current = {}; // refers to the index value of the event in chartData
        for (var i=0; i<data.length; i++){
          self.current.index = data[i].startHere ? i : self.current.index;
        }
        self.previous = {}; // not being used right now

        // setup elements
        self._setupElements();
        
        // setup elementSizes
        self._setElementSizes();

            
      },
   
      _setupElements: function(){
        var self = this,
            width = self.dims.width,
            height = self.dims.height, 
            yScale = self.yScale,
            data = self.chartData,
            circleRadius = width/3.5;

        self.circleRadius = circleRadius

        // define zoom function
        self.zoom = d3.behavior.zoom()
          .y(self.yScale)
          .size([width, height])
          .scaleExtent([1, 8]) // maximum of 8x original scale
          .on("zoom", zoomed); // should this be disabled? how to call it on another event?
        

        // set dims             
        self.svg = d3.select(self.$.chart)
          .call(self.zoom); // allows scrolling through timeline

        // defines what happens when zoomed 
        function zoomed() {
          console.log("***");
          console.log(d3.event);
          console.log("---");
          // console.log(d3.event.scale);
          // console.log(this);
          
          // zooms in on line and spreads the events out vertically
          self.events
             .attr('transform', function(d){ 
              return "translate(0," + yScale(d.date) + ")"});
          
        
          var selected = d3.select(this); // this is the SVG

          self.events.selectAll('.circle')
            .classed('current', false)
            .attr('r', 0);

          // selected
          //   .classed('current', true);

          // enlarge only the circle marked current
          // selected.select('.circle')
          //   .transition().duration(100)
          //   .attr('r', circleRadius);

          // selected.select('.label-text')
          //   .transition().duration(100)
          //   .attr('opacity', 0);

          // selected.select('.headline-text')
          //   .transition().duration(100)
          //   .attr('font-size', '1.2em')
          //   .attr('opacity', 1);

          // selected.select('.body-text')
          //   .transition().duration(100)
          //   .attr('font-size', '0.7em')
          //   .attr('opacity', 1);




          // Rather than this, we can call zoom on the circles themselves.
          // enlarge all circles
          // self.events.select('.circle')
          //   .transition().duration(100)
          //   .attr('r', circleRadius);

          // self.events.select('.label-text')
          //   .transition().duration(100)
          //   .attr('opacity', 0);

          // self.events.select('.headline-text')
          //   .transition().duration(100)
          //   .attr('font-size', '1.3em')
          //   .attr('opacity', 1);

          // self.events.select('.body-text')
          //   .transition().duration(100)
          //   // .attr('font-size', '0.7em')
          //   .attr('opacity', 1);

          // self.events.select('.detail-text')
          //   .transition().duration(100)
          //   .attr('opacity', 1);
        }


        // create container
        var g = self.svg.append('g')
          .attr('class','container');

        // append timeline
        self.timeline = g.append('line')
          .attr('class', 'axis')
          .attr('stroke-width', 1.5);
        
        // TODO: append endpoints

        // append group for each event
        self.events = g.selectAll('g.event')
          .data(data)
          .enter().append('g')
          .attr('class', 'event')
          .classed('current', function(d,i){ return i == 0 ? true : false; });
          
          // .on('click', function(d,i){
            
          //   for (var prop in self.current){
          //     self.previous[prop] = self.current[prop];
          //   }
          //   // self.previous.yPos = self.current.yPos;

          //   self.current.g = d3.select(this);
          //   self.current.circle = self.current.g.select('.circle');
          //   self.current.yPos = self.current.circle.attr('cy');
          //   self.current.index = i;
          //   self.events
          //     .classed('current', false);
          //   self.current.g
          //     .classed('current', true);


          //   console.log(self.previous);
          //   console.log(self.current);
          //   self._jumpToCurrent();
          // });

        // append labels
        self.labels = self.events
          .append('text')
          .text(function(d){ return d.headline; })
          .attr('class', 'label-text fill-foreground')
          .attr('dx', 0)
          .attr('dy', 0);

        self.labelDetails = self.events
          .append('text')
          .text(function(d){ return d.detail; })
          .attr('class', 'label-details fill-foreground')
          .attr('dx', 0)
          .attr('dy', 0)
          .attr('font-variant', 'small-caps');
          
        // append content circles
        self.circles = self.events
          .append('circle')
          .attr('class', 'circle stroke-foreground fill-background')
          // .classed('current', function(d,i){ console.log(i == self.current.index ? true : false); return i == self.current.index ? true : false;})
          .attr('stroke-width', 1.5);
          

        // append dots for events
        self.dots = self.events
          .append('circle')
          .attr('class', 'dot stroke-foreground fill-foreground')
          .attr('stroke-width', 1.5);
          
        
        self.headlines = self.events
          .append('text')
          .attr('class', 'headline-text fill-foreground')
          .attr('dx', 0)
          .attr('dy', 0)
          .attr('text-anchor', 'middle');
          
        self.bodytexts = self.events  
          .append('text')
          .attr('class', 'body-text fill-foreground')
          .attr('dx', 0)
          .attr('dy', 0)
          .attr('text-anchor', 'middle');
          
        
        self.details = self.events  
          .append('text')
          .attr('class', 'detail-text fill-foreground')
          .attr('dx', 0)
          .attr('dy', 0)
          .attr('text-anchor', 'middle')
          .attr('font-variant', 'small-caps');
          

      },

      _setElementSizes: function(){
        var self = this,
            yScale = self.yScale,
            width = self.dims.width,
            height = self.dims.height,
            circleRadius = self.circleRadius;

        self.svg
          .attr('height', height)
          .attr('width', width);

        self.timeline
          .attr('y1', self.yScale(self.startDate))
          .attr('y2', self.yScale(self.endDate))
          .attr('x1', width/2)
          .attr('x2', width/2);

        self.labels
          .attr('text-anchor', function(d,i){ return i % 2 == 0 ? "start" : "end";}) 
          .attr('x', function(d,i){return i % 2 == 0 ? width/2 + self.dims.margin.label : width/2 - self.dims.margin.label ;})
          .attr('y', function(d){ return yScale(d.date) + 5; })
          .call(self._wrapText, width/2);

        self.labelDetails
          .attr('text-anchor', function(d,i){ return i % 2 == 0 ? "start" : "end";}) 
          .attr('x', function(d,i){return i % 2 == 0 ? width/2 + self.dims.margin.label : width/2 - self.dims.margin.label ;})
          .attr('y', function(d){ return yScale(d.date) + 18; })
          .attr('font-weight', '100')
          .call(self._wrapText, width/2);

        self.circles
          .attr('cx', width/2)
          .attr('cy', function(d){
            return yScale(d.date) + self.circleRadius;
          })
          .attr('r', 0);

        self.dots
          .attr('cx', width/2)
          .attr('cy', function(d){
            return yScale(d.date);
          })
          .attr('r', 3);

        self.headlines
          .attr('x', width/2)
          .attr('y', function(d){ return yScale(d.date) + circleRadius/1.75; })
          // .attr('font-size', '1.2em')
          .attr('font-size', '0em')
          .attr('opacity', 0)
          .text(function(d){return d.headline});

        self.bodytexts
          .attr('x', width/2)
          .attr('y', function(d){ return yScale(d.date) + circleRadius/1.2; })
          .text(function(d){return d.body})
          // .attr('font-size', '0.7em')
          .attr('font-size', '0.7em')
          .attr('font-weight', 100)
          .attr('opacity', 0)
          .call(self._wrapText, circleRadius*1.75);

        self.details
          .attr('x', width/2)          
          .attr('y', function(d){ return yScale(d.date) + circleRadius*1.7; })
          .text(function(d){return d.detail})
          // .attr('font-size', '0.7em')
          .attr('font-size', '0.75em')
          .attr('opacity', 0)
          .call(self._wrapText, circleRadius*1.75);

      // function(d,i){return i==self.current ? circleRadius : 0

      },
      _wrapText: function (text, width) {
          console.log("wrap");
          text.each(function() {
            var text = d3.select(this),
                words = text.text().split(/\s+/).reverse(),
                word,
                line = [],
                lineNumber = 0,
                lineHeight = 1.1, // ems
                y = text.attr("y"),
                x = text.attr("x"),
                dy = parseFloat(text.attr("dy")),
                tspan = text.text(null).append("tspan").attr("x", x).attr("y", y).attr("dy", dy + "em");
 
            while (word = words.pop()) {
              line.push(word);
              tspan.text(line.join(" "));
              if (tspan.node().getComputedTextLength() > width) {
                line.pop();
                tspan.text(line.join(" "));
                line = [word];
                tspan = text.append("tspan").attr("x", x).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
              }
            }
          });
        },
      _jumpToCurrent: function(){
        var self = this,
            width = self.dims.width,
            yScale = self.yScale,
            circleRadius = width/5;

        var yTrans;
        if(self.previous.yPos){
           yTrans =  self.current.yPos - self.previous.yPos;
        } else {
           yTrans = 0;
        }

        self.svg.transition().delay(2000).duration(1000)
            .call(self.zoom
              .scale(5)
              .translate([width/2, -300 ]) // this is a relative translate, not absolute
              .event);


      },


      reset: function(hard) {

          
     
      },
      
      animate: function() {
        var self = this,
            yScale = self.yScale,
            width = self.width, 
            height = self.height;

        




        // zoom in on the current point
        // console.log(self.current);
        
        self._jumpToCurrent(); // start at the first event


        
        // transform the content circle to enlarge
        // swipe events to navigate events
        // click events to zoom on a specific event
        // ability to zoom in out




      },


      resize: function() {
          
          var self = this;
          
      

      },

      updateData: function() {


          var self = this;

   
      }

      
    });

// on click, set new point to current and old to previous
// calculate translate distance from previous point
// translate to new point 
// enlarge circle 

// on scroll 
// determine direction? 
// determine next point and distance to point 



  </script>
</polymer-element>
