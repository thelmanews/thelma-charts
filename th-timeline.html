<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="th-d3-chart.html">

<polymer-element name="th-timeline" extends="th-d3-chart">
  <template>   
    <core-style ref="theme"> </core-style>
    <style>
      .current {

      }

      .headline-text {

      }

      .body-text {

      }

      .detail-text {

      }

      .label-text {
        font-size: 0.8em;
      }

      .event-info {
        background-color: red;
        position: absolute;
        z-index: 20;
        font-size: 20px;
        color: yellow;
      }

    </style>
    
    <svg id="chart"></svg> 
  </template> 
  
  <script>

    Polymer('th-timeline', {
      chartData: [
        {date: '1', headline: 'July 15th', body:"UN asked for a five-hour ceasefire for humanitarian reasons.  Fighting resumed soon afterwards.", detail: '', image: '', fill:'', startHere: true},
        {date: '2', headline: 'July 17th', body:'', detail: '', image: '', fill:'', startHere: false},
        {date: '3', headline: 'July 20th', body:'', detail: '', image: '', fill:'', startHere: false},
        {date: '4', headline: 'July 25th', body:'', detail: '', image: '', fill:'', startHere: false},
        {date: '5', headline: 'July 26-28th', body:'', detail: '', image: '', fill:'', startHere: false},
        {date: '6', headline: 'August 4th', body:'', detail: 'Morning', image: '', fill:'', startHere: false},
        {date: '7', headline: 'August 4th', body:'', detail: 'Evening', image: '', fill:'', startHere: false}
      ],
      scale: "time", // or 'linear' if no dates
      startDate: '0',
      endDate: '10',
      theme: 'light',
      init: function() {
        var self = this,
            data = self.chartData;

        // setup dimensions
        self.dims = self.setupDimensions(self);
        
         
        // setup scale
        self.yScale = d3.time.scale()
          .domain([self.startDate, self.endDate])
          .range([0, self.chartHeight]);

        // set starting point
        self.current = {}; // refers to the index value of the event in chartData
        for (var i=0; i<data.length; i++){
          self.current.index = data[i].startHere ? i : self.current.index;
        }
        self.previous = {};
        // setup elements
        self._setupElements();
        // setup elementSizes


            
      },
   
      _setupElements: function(){
        var self = this,
            width = self.dims.width,
            height = self.dims.height, 
            yScale = self.yScale,
            data = self.chartData,
            circleRadius = width/3.5;

        // define zoom function
        var zoom = d3.behavior.zoom()
          .y(yScale)
          .size([width, height])
          .scaleExtent([1, 8]) // maximum of 8x original scale
          .on("zoom", zoomed); // should this be disabled? how to call it on another event?
        self.zoom = zoom;

        function zoomed() {
          
          self.events.selectAll('.circle')
            .classed('current', false)
            .attr('r', 0);

          var selected = d3.select(this);

          selected
            .classed('current', true);

          self.events
             .attr('transform', function(d){ return "translate(0," + yScale(d.date) + ")"});

          selected.select('.circle')
            .transition().duration(100)
            .attr('r', circleRadius);

          selected.select('.label-text')
            .transition().duration(100)
            .attr('opacity', 0);

          selected.select('.headline-text')
            .transition().duration(100)
            .attr('font-size', '1.2em')
            .attr('opacity', 1);

          selected.select('.body-text')
            .transition().duration(100)
            .attr('font-size', '0.7em')
            .attr('opacity', 1);
        }


        // set dims             
        self.svg = d3.select(self.$.chart)
          .attr('height', height)
          .attr('width', width)
          .call(zoom); // need this to be able to scroll through timeline

        // create container
        var g = self.svg.append('g')
          .attr('class','container');

        // append timeline
        self.timeline = g.append('line')
          .attr('class', 'axis')
          .attr('stroke-width', 1.5)
          .attr('y1', yScale(self.startDate))
          .attr('y2', yScale(self.endDate))
          .attr('x1', width/2)
          .attr('x2', width/2);


        // TODO: append endpoints

        // append group for each event
        self.events = g.selectAll('g.event')
          .data(data)
          .enter().append('g')
          .attr('class', 'event')
          .classed('current', function(d,i){ return i == 0 ? true : false; });
          // .on('click', function(d,i){
            
          //   for (var prop in self.current){
          //     self.previous[prop] = self.current[prop];
          //   }
          //   // self.previous.yPos = self.current.yPos;

          //   self.current.g = d3.select(this);
          //   self.current.circle = self.current.g.select('.circle');
          //   self.current.yPos = self.current.circle.attr('cy');
          //   self.current.index = i;
          //   self.events
          //     .classed('current', false);
          //   self.current.g
          //     .classed('current', true);


          //   console.log(self.previous);
          //   console.log(self.current);
          //   self._jumpToCurrent();
          // });



        // append labels
        self.labels = self.events
          .append('text')
          .text(function(d){ return d.headline; })
          .attr('dx', 0)
          .attr('dy', 0)
          .attr('text-anchor', function(d,i){ return i % 2 == 0 ? "start" : "end";}) 
          .attr('x', function(d,i){return i % 2 == 0 ? width/2 + self.dims.margin.label : width/2 - self.dims.margin.label ;})
          .attr('y', function(d){ return yScale(d.date); })
          .attr('transform', 'translate(0, 5)')
          
          .attr('class', 'label-text fill-foreground')
          .call(wrap, width/2);
        // TODO: add detail line below label and position them properly

        // append content circles
        self.circles = self.events
          .append('circle')
          .attr('class', 'circle stroke-foreground fill-background')
          // .classed('current', function(d,i){ console.log(i == self.current.index ? true : false); return i == self.current.index ? true : false;})
          .attr('stroke-width', 1.5)
          .attr('cx', width/2)
          .attr('cy', function(d){
            return yScale(d.date) + circleRadius;
          })
          .attr('r', 0);

        // append dots for events
        self.dots = self.events
          .append('circle')
          .attr('class', 'dot stroke-foreground fill-foreground')
          .attr('stroke-width', 1.5)
          .attr('cx', width/2)
          .attr('cy', function(d){
            return yScale(d.date);
          })
          .attr('r', 3);

        // // WHY DOESNT THIS SHOW UP?
        // self.eventInfo = self.events
        //   .append('div')
        //   .attr('class', 'event-info fi')
        //   .style('width', circleRadius*2)
        //   .style('height', circleRadius*2)
        //   .style('background-color', 'red')
        //   .attr('x', width/2)
        //   .attr('y', function(d){ return yScale(d.date); })
        //   .html(function(d){return d.headline;});
        
        self.headlines = self.events
          .append('text')
          .attr('class', 'headline-text fill-foreground')
          .attr('dx', 0)
          .attr('dy', 0)
          .attr('x', width/2)
          .attr('text-anchor', 'middle')
          .attr('y', function(d){ return yScale(d.date) + circleRadius/2; })
          // .attr('font-size', '1.2em')
          .attr('font-size', '0em')
          .attr('opacity', 0)
          .text(function(d){return d.headline});

        self.bodytexts = self.events  
          .append('text')
          .attr('class', 'body-text fill-foreground')
          .attr('dx', 0)
          .attr('dy', 0)
          .attr('x', width/2)
          .attr('text-anchor', 'middle')
          .attr('y', function(d){ return yScale(d.date) + circleRadius/1.25; })
          .text(function(d){return d.body})
          // .attr('font-size', '0.7em')
          .attr('font-size', '0.7em')
          .attr('opacity', 0)
          .call(wrap, circleRadius*1.75);
        


        function wrap(text, width) {
          text.each(function() {
            var text = d3.select(this),
                words = text.text().split(/\s+/).reverse(),
                word,
                line = [],
                lineNumber = 0,
                lineHeight = 1.1, // ems
                y = text.attr("y"),
                x = text.attr("x"),
                dy = parseFloat(text.attr("dy")),
                tspan = text.text(null).append("tspan").attr("x", x).attr("y", y).attr("dy", dy + "em");
 
            while (word = words.pop()) {
              line.push(word);
              tspan.text(line.join(" "));
              if (tspan.node().getComputedTextLength() > width) {
                line.pop();
                tspan.text(line.join(" "));
                line = [word];
                tspan = text.append("tspan").attr("x", x).attr("y", y).attr("dy", ++lineNumber * lineHeight + dy + "em").text(word);
              }
            }
          });
        }
          


      },
      _setElementSizes: function(){
        var self = this;

      // function(d,i){return i==self.current ? circleRadius : 0

      },
      
      _jumpToCurrent: function(){
        var self = this,
            zoom = self.zoom,
            width = self.dims.width,
            yScale = self.yScale,
            circleRadius = width/5;

        var yTrans;
        if(self.previous.yPos){
           yTrans =  self.current.yPos - self.previous.yPos;
        } else {
           yTrans = 0;
        }

        self.svg.transition().duration(1000)
            .call(zoom
              .scale(3)
              .translate([width/2, yTrans]) // this is a relative translate, not absolute
              .event);
      },

      reset: function(hard) {

          
     
      },
      
      animate: function() {
        var self = this;

        // zoom in on the current point
        // console.log(self.current);
        
        self._jumpToCurrent(); // start at the first event


        
        // transform the content circle to enlarge
        // swipe events to navigate events
        // click events to zoom on a specific event
        // ability to zoom in out




      },


      resize: function() {
          
          var self = this;
          
      

      },

      updateData: function() {


          var self = this;

   
      }

      
    });

// on click, set new point to current and old to previous
// calculate translate distance from previous point
// translate to new point 
// enlarge circle 

// on scroll 
// determine direction? 
// determine next point and distance to point 



  </script>
</polymer-element>
