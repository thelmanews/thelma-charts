<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="th-d3-chart.html">

<polymer-element name="th-spectrum-chart" extends="th-d3-chart">

	<template>
	    <core-style ref="theme"></core-style>
	    <style>

	      :host {
	        display: inline-block;
	        position: relative;
	      }
	      #chart {

	      }
	      #chart text.label {
	        /*font-size: 13px;*/
	        /*font-weight: 300;*/
	      }

	      #data_errors {  
	        display: none;
	        font-size: 14px;
	        color: red;
	        position: absolute;
	        top: 0;
	        left: 0;
	      }

	    </style>

	    <svg id="chart"></svg>

	    <ul id="data_errors">
	    </ul>  

	    <!-- to allow embeded th-editor component -->
	    <content select="th-editor"></content> 
	    
	</template>

	<script>
		Polymer('th-spectrum-chart', {
		  chartWidth: 280,
		  chartHeight: 250, 
		  chartData: [
		  	 {"label": "Medicaid", "color": "", "pattern": "",  "range_min_value": 10, "range_min_display_value": "$10", "range_max_value": 50, "range_max_display_value": "$50"},
        {"label": "Federal", "color": "", "pattern": "",  "range_min_value": 40, "range_min_display_value": "$40", "range_max_value": 60, "range_max_display_value": "$60"},
        {"label": "Medicare",  "color": "", "pattern": "stripe", "range_min_value": 70, "range_min_display_value": "$70", "range_max_value": 100, "range_max_display_value": "$100"}],
		  orientation: 'vertical',
		  //animationDelay: 500,
		  init: function() {
		    var self = this;
          
        // setup dimensions
        // self.dims = self.setupDimensions(self);

        self._setAllDims();

        

        // setup scales

	      
          // setup chart area
	      var chart_svg = this.$.chart;
          self.svg = d3.select(chart_svg);

	      /* adding stripe pattern and mask */

	      var defs = self.svg.append("defs");
	      defs.append("pattern")
	        .attr("id","pattern-stripe")
	        .attr("width", 1)
	        .attr("height", 5)
	        .attr("patternUnits", "userSpaceOnUse")
	        .attr("patternTransform", "rotate(45)")
	        .append("rect")
	          .attr("width", 1)
	          .attr("height", 1)
	          .attr("transform", "translate(0,0)")
	          .attr("fill", "white");

	      defs.append("mask")
	      .attr("id","mask-stripe")
	      .append("rect")
	        .attr("width", "100%")
	        .attr("height", "100%")
	        .attr("x", 0)
	        .attr("y", 0)
	        .attr("fill", "url(#pattern-stripe)");
          

		      self.container =  self.svg.append('g');



		      self.spectrum = self.container.selectAll('.spectrum').data([self._wholeRange]).enter().append('rect')
		      	
		      self.bars = this.container.selectAll('.bar').data(this.chartData).enter().append('rect');

		      self.labels = this.container.selectAll('.label').data(this.chartData).enter().append('text');

		      self.spectrum.attr('class','spectrum')
		      	.style('fill', function(d,i) {return '#FFF';});

		      self.values = this.container.selectAll('.value').data(this.chartData).enter().append('text')

		      self._setElementSizes();	

		      self.bars.attr('height', 0)
		      		   .attr('width',self.dims.bar.width);


		      self.labels.style('opacity', 0);

		      self.values.style('opacity', 0);

		      self.spectrum
		        .attr('x', self.dims.labels.width + self.dims.margin.label )
		        .attr('y', function(d) {return self.y(self._wholeRange.min)})
		        .attr('width',self.dims.bar.width)
		        .attr('height', function(d) {return self.y(self._wholeRange.max)});


	      


		  },

		  _setAllDims: function() {

		  	  var self = this;

	          self.dims = self.setupStackedDims(self);

		      var dataMargin = 0.1;  // 10% extra space     

		      var minmin = d3.min(self.chartData, function(d) { return d.range_min_value;});

		      var maxmax = d3.max(self.chartData, function(d) { return d.range_max_value;});

		      var marginValue = (maxmax-minmin)* dataMargin;
		      self._wholeRange = {min : minmin-marginValue, max:  maxmax+marginValue};


	          var scales = self.simpleScaleBuilder(this.dims.width, this.dims.height, self.chartData);

	          self.y = scales.y;
	          self.x = scales.x;

		      self.y.domain([self._wholeRange.min, self._wholeRange.max]); 
        
		  },


		  _setElementSizes: function() {

			  	var self = this;

			  	self.svg.attr('width', self.dims.width + self.dims.margin.left + self.dims.margin.right)
		          .attr('height', self.dims.height + self.dims.margin.top + self.dims.margin.bottom);


	           self.container.attr('transform', 'translate(' + self.dims.margin.left + ',' + self.dims.margin.top + ')');


			   self.bars
		        .attr('class','bar')
		        .attr("class", function(d,i){ return "bar data"+i; })
		        .style('mask', function(d) { return d.pattern ?  'url(#mask-stripe)' : 'none' ;})
		        .style('fill', function(d){ return d.color;})
		        .style('stroke', function(d){ return d.color;});

		      self.labels
		      	.attr('class','label')
		        .attr("class", function(d,i){return "label data"+i;})
		        .style('text-anchor','end')
		        .text(function(d) {return d.label;})
	            .style('fill', function(d){ return d.color;})
	            .style('stroke', function(d){ return d.color;});
		      
		      self.values
		      	.attr('font-weight', 300)
		      	.attr('class', function(d,i){return "defaultvalue value data"+i;})
		        .style('opacity', 0)
		        .text(function(d) {
	            return d.range_max_display_value && d.range_min_display_value ? (d.range_min_display_value + " - " + d.range_max_display_value) : (d.range_min_value.toString() + " - " + d.range_max_value.toString()) ;
	          	})
	            .style('fill', function(d){ return d.color;})
	            .style('stroke', function(d){ return d.color;});


		  },

		  resize: function() {

		      var self = this;
		      
		      self._setAllDims();

		      self._setElementSizes();

		      self.animate();

		  },


		  reset: function(hard) {
		      var self = this;
		      var height= this.height;
		      if(hard) {
			      self.bars.transition().duration(1).attr('height', 0);
			      self.labels.transition().duration(1).style('opacity', 0);
			      self.values.transition().duration(1).style('opacity', 0);
		      }
		      else {
			      self.bars.transition().duration(this.animationDelay).attr('height', 0);
			      self.labels.transition().duration(this.animationDelay).style('opacity', 0);
			      self.values.transition().duration(this.animationDelay).style('opacity', 0);
			  }
		      
		  },
		  
		  animate: function() {

	  		var self = this;
	        var y = self.y;
	        var labels = self.labels;
	        var delay = self.animationDelay;

	        self.spectrum.transition().duration(delay)
		        .attr('x', self.dims.labels.width + self.dims.margin.label )
		        .attr('y', function(d) {return self.y(self._wholeRange.min)})
		        .attr('width',self.dims.bar.width)
		        .attr('height', function(d) {return self.y(self._wholeRange.max)});

	        self.bars.transition().duration(delay)
	        	.attr('x', self.dims.labels.width + self.dims.margin.label )
		        .attr('y', function(d) {return self.dims.height - self.y(d.range_max_value)})
		        .attr('width',self.dims.bar.width)
	        	.attr('height', function(d) {
	        		//to avoid negative heights
	        		var h = Math.max( self.y(d.range_max_value - d.range_min_value), 0); 
	        		return h;
	        	});

	        self.labels.transition(delay).duration(delay)//.delay(function(d,i) { return i*delay;})
		        .attr('x', self.dims.labels.width)
		        .attr('y', function(d) {return self.dims.height - self.y(d.range_max_value - ((d.range_max_value - d.range_min_value)/2));}) 
		        .style('opacity', 1);
	        
	        self.values.transition(delay).duration(delay)//.delay(function(d,i) { return i*delay;})
		        .attr('x', self.dims.labels.width + self.dims.margin.label*2 + self.dims.bar.width)
		        .attr('y', function(d) {return self.dims.height - self.y(d.range_max_value - ((d.range_max_value - d.range_min_value)/2));}) 
		        .style('opacity', 1);

		  },

		  updateData: function() {


		  	  var self = this;

		      self._setAllDims();  	  

			  self.bars = self.container.selectAll('.bar').data(self.chartData);
			  self.labels = self.container.selectAll('.label').data(self.chartData);
			  self.values=self.container.selectAll('.value').data(self.chartData);

		  	  if(self.dataLength!=self.chartData.length)
		  	  {



			      self.bars.enter().append('rect').attr('class','bar').attr('height', 0);

			      self.labels.enter().append('text').attr('class','label');
			      self.values.enter().append('text').attr('class','value').attr('y', self.dims.height);


			      self.bars.exit().transition().duration(1000).attr('height', 0).attr('y', self.dims.height).style('opacity', 0).remove();
			      self.labels.exit().transition().duration(1000).style('opacity', 0).remove();
			      self.values.exit().transition().duration(1000).style('opacity', 0).remove();
			      
			     //self.resize();
			     self._setElementSizes();

			    }

		      // this is independent of size but dependent on data
		      self.labels.text(function(d) {return d.label;});
		      self.values.text(function(d) {return d.display_value ? d.display_value : d.value ;});


		      self.animate();

		  },
		  chartSpecificDataValidate: function() {

          var errors = [],
              numOfSets = this.chartData.length;

					// There should be at least one range of values.
          if(numOfSets === 0) {
            errors.push({input: numOfSets, msg: 'Please include at least one value range and label.'});
          } else {
          	for (var i=0; i < numOfSets; i++){
          		// Each range should have a min and max value.
          		if (!this.chartData[i].range_min_value || !this.chartData[i].range_max_value){ 
            		errors.push({ input: this.chartData, msg: 'You must include a min and max value for each datapoint.'});
          		}
          		// Each range should have a label.
          		if (!this.chartData[i].label){ 
          			errors.push({ input: this.chartData, msg: 'You must include a label for each range.'});	
          		}
          		// The max value should always be larger than the min.
          		if (this.chartData[i].range_min_value > this.chartData[i].range_max_value) {
          			errors.push({ input: this.chartData, msg: 'Max value must be greater than min value.'});	
          		}
          	}
        	}
        
          return errors;
          },

          getMetaData: function() {
          	return {
			  "name": "th-spectrum-chart",
			  "description": "Thelma spectrum chart",
			  "category":"chart",
			  "version": "0.0.1",
			  "thumbnail":"spectrum.jpg", 
			  "tags":["chart", "column", "animated"],
			  "content":false,
			  "inputAttr": {
			    "chartWidth":{"friendly":"Width", "type":"int", "default":275},
			    "chartHeight":{"friendly":"Height", "type":"int", "default":250},
			    "chartData":{"friendly":"Data", "type":"table-repeating","rows":2, 
			      "fields":{
			        "label":{"friendly":"Label", "type":"string", "default":"Medicaid"},
			        "range_min_value":{"friendly":"Min Val", "type":"int", "default":10},
			        "range_min_display_value":{"friendly":"Min Disp", "type":"string", "default":"$10"},
			        "range_max_value":{"friendly":"Value", "Max Val":"int", "default":50},
			        "range_max_display_value":{"friendly":"Max Disp", "type":"string", "default":"$50"},
			        "color":{"friendly":"Color", "type":"colorPicker", "default":"", "optional":true},
			        "pattern":{"friendly":"Pattern", "type":"string", "default":"stripe", "optional":true}
			      },
			      "default":[
			        {"label": "Medicaid", "color": "", "pattern": "",  "range_min_value": 10, "range_max_value": 50},
			        {"label": "Federal", "color": "", "pattern": "",  "range_min_value": 40, "range_max_value": 60},
			        {"label": "Medicare",  "color": "", "pattern": "stripe", "range_min_value": 70, "range_max_value": 100}]
			    }
			  }
			}
          }
		  
		});
	</script>


</polymer-element>
