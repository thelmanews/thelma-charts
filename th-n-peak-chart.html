<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="th-d3-chart.html">

<polymer-element name="th-n-peak-chart" extends="th-d3-chart">

  <script>
    Polymer('th-n-peak-chart', {
      chartData: [
        {label: 'Platinum', value: 50, display_value: '$50'},
        {label: 'Gold', value: 45, display_value: '$45'},
        {label: 'Silver', value: 30, display_value: '$30'},
        {label: 'Bronze', value: 25, display_value: '$25'}   
      ],
      init: function() {
        var margin = {
              top : 15,
              right : 0,
              bottom : 20,
              left : 0,
              label: 3
          }, 
          width = this.chartWidth*0.95 - margin.left - margin.right, 
          height = this.chartHeight*0.55 - margin.top - margin.bottom;
          this.height = height;

          // peak declarations
          var numOfPeaks = this.chartData.length, 
              overlap = 1.2, // the higher the number, the more overlap
              peakWidth = (width / numOfPeaks)*overlap,
              peakWidthOverlap = peakWidth*overlap;
          var peakLineStart = d3.svg.line()
              .x(function(d) { return d.x; })
              .y(function(d) { return height; });
          var peakLine = d3.svg.line()
              .x(function(d) { return d.x; })
              .y(function(d) { return -d.y; });
          this.peakLine = peakLine;
          this.peakLineStart = peakLineStart;

          // scales
          var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
          var y = d3.scale.linear().range([0, height]);
          this.y = y;

          // chart positioning
          var chart_svg = this.$.chart;
          var colors = d3.scale.category10();
          colors.domain(this.chartData.length);

          this.container = d3.select(chart_svg).attr('width', width + margin.left + margin.right)
              .attr('height', height + margin.top + margin.bottom)
              .append('g')
              .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
          var max = d3.max(this.chartData, function(d) {return d.value});

          y.domain([0, max]); 
          x.domain(this.chartData.map(function(d) {
            return d.label;
          }));
 
          // transform chartData for paths
          var lastEdge = 0;
          var peakData = this.chartData.map(function(i){
            var coordinates = [{ x: lastEdge, y: -height},
                               {x: lastEdge + peakWidth, y: -height},
                               { x: lastEdge + peakWidth/2, y: -height+y(i.value)}];
            lastEdge = lastEdge + (peakWidth/overlap)/overlap;
            return coordinates;
          });

          // append peaks
          this.peaks = this.container.selectAll('.peak')
            .data(peakData)
            .enter()
            .append('path')
              .attr('class','peak')
              .attr('fill', function(d,i) {return d.color ? d.color : colors(i);})
              .attr('d', peakLineStart)
              .attr('opacity', 0);
      
          // append labels
          this.labels = this.container.selectAll('.label')
            .data(this.chartData)
            .enter().append('text')
              .attr('class','label')
              .style('fill', function(d,i) {return d.color ? d.color : colors(i);})
              //.style('opacity', 0)
              .style('text-anchor','middle')
              .attr('x', function(d,i) { return ((peakWidth/2) + (peakWidth/overlap*i/overlap)); })
              .attr('y', height + 14) //12: font size
              .text(function(d) {return d.label;});
            
          // append values  
          this.values = this.container.selectAll('.value')
            .data(this.chartData)
            .enter().append('text')
              .attr('class','value')
              .style('fill', function(d,i) {return d.color ? d.color : colors(i);})
              .style('text-anchor','middle')
              .style('opacity', 0)
              .attr('x', function(d,i) { return ((peakWidth/2) + (peakWidth/overlap*i/overlap)); })
              .text(function(d) {return d.display_value ? d.display_value : d.value ;});

      },
      reset: function() {
          var height= this.height;
          this.peaks.transition().duration(this.animationDelay).attr('d', this.peakLineStart).attr('opacity', 0);
          this.values.transition().duration(this.animationDelay).attr('y', height ).style('opacity', 0);
          
      },
      
      animate: function() {

            var y = this.y;
            var height= this.height;

            this.peaks.transition()
              .attr('opacity', 0.8)
              .duration(this.animationDelay) 
              .attr("d", this.peakLine);
            
            this.values.transition(this.animationDelay)
              .duration(this.animationDelay)
              .attr('y', function(d) {return height - y(d.value) - 2;})
              .style('opacity', 1);

      },
      chartSpecificDataValidate: function() {
        
          var errors = [],
              numOfPeaks = this.chartData.length;

          // There should be at least value.
          if(numOfPeaks === 0) {
            errors.push({input: numOfPeaks, msg: 'Please provide at least one value for the chart.'});
          } else {
            for (var i=0; i < numOfPeaks; i++){
              
              // There should be a value for every bar.
              if (!this.chartData[i].value){ 
                errors.push({ input: this.chartData, msg: 'You must include a value for every peak.'});
              }
              
              // There should be a label for every bar.
              if (!this.chartData[i].label){ 
                errors.push({ input: this.chartData, msg: 'You must include a label for every peak.'});
              }
            }
          }

          return errors;
        }
      
    });


  </script>
</polymer-element>
