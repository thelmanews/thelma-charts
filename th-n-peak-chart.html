<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="th-d3-chart.html">

<polymer-element name="th-n-peak-chart" extends="th-d3-chart">

  <script>
    Polymer('th-n-peak-chart', {
      chartData: [
        {label: 'Platinum', value: 50, display_value: '$50'},
        {label: 'Gold', value: 45, display_value: '$45'},
        {label: 'Silver', value: 30, display_value: '$30'},
        {label: 'Bronze', value: 25, display_value: '$25'}
      ],
      init: function() {
        var self = this;

        // setup dimensions
        self.dims = self.setupDimensions(self);
        self.width = self.dims.width;
        self.height = self.dims.height;
        
        // format chart elements based on chartData
        self.bars = self.formatBars(self, 1.25); // pass in overlap to override default
        self.labels = self.formatLabels(self);
        self.values = self.formatValues(self);

        // create scales
        var scales = self.simpleScaleBuilder(self.width, self.height, self.chartData);
        self.x = scales.x;
        self.y = scales.y;

        // setup container, rearrange data for peaks, setup starting state of peaks
        self._setupContainerSize();
        self.peakData = self._setupData();
        self._setupElements();

      },
      _setupContainerSize: function(){
        var self = this,
            margin = self.dims.margin,
            width = self.dims.width,
            height = self.dims.height,
            chart_svg = self.$.chart;

        self.container = d3.select(chart_svg).attr('width', width + margin.left + margin.right)
            .attr('height', height + margin.top + margin.bottom)
            .append('g')
            .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

      },
      _setupData: function(){
        var self = this,
            bars = self.dims.bars
            height = self.dims.height,
            y = self.y,
            lastEdge = 0;

        var peakData = self.chartData.map(function(i){
          var coordinates = [{ x: lastEdge, y: -height},
                           {x: lastEdge + bars.width, y: -height},
                           { x: lastEdge + bars.width/2, y: -height+y(i.value)}];
          lastEdge = lastEdge + (bars.width/bars.overlap)/bars.overlap;
          return coordinates;
        });
        return peakData;
      },
      _setupElements: function(){
        var self = this,
            peakData = self.peakData,
            labels = self.labels,
            bars = self.bars,
            values = self.values;

        // starting and ending lines to draw peaks
        self.peakLineStart = d3.svg.line()
              .x(function(d) { return d.x; })
              .y(function(d) { return height; });
        self.peakLine = d3.svg.line()
              .x(function(d) { return d.x; })
              .y(function(d) { return -d.y; });
         
        // append peaks
        self.peaks = self.container.selectAll('.peak')
          .data(peakData)
          .enter()
          .append('path')
            .attr('class', function(d,i){return "peak data"+i;})
            .attr('d', self.peakLineStart)
            .attr('opacity', 0);
    
        // append labels
        self.labels = self.container.selectAll('.label')
          .data(self.chartData)
          .enter().append('text')
            .attr('class', function(d,i){return "label data"+i;})              
            .style('text-anchor', function(){ return labels.angle > 0 ? "left" : "middle"})
            .attr('transform', function(d,i){
              var xPos = (bars.width/2) + (bars.width/bars.overlap*i/bars.overlap);
              var yPos = height + 16;
              var rotation = labels.angle;
              return "translate("+xPos+","+yPos+") rotate("+ rotation +")";
            })
            .text(function(d) {return d.label;});
          
        // append values  
        self.values = self.container.selectAll('.value')
          .data(self.chartData)
          .enter().append('text')
            .attr('class', function(d,i){return "value data"+i;})
            .style('text-anchor','middle')
            .attr('font-size', values.size)
            .style('opacity', 0)
            .attr('x', function(d,i) { return ((bars.width/2) + (bars.width/bars.overlap*i/bars.overlap)); })
            .attr('y', height)
            .text(function(d) {return d.display_value ? d.display_value : d.value ;});

      },
      reset: function() {
        var self = this,
            height= self.height;
        self.peaks.transition().duration(self.animationDelay).attr('d', self.peakLineStart).attr('opacity', 0);
        self.values.transition().duration(self.animationDelay).attr('y', height ).style('opacity', 0);
          
      },
      
      animate: function() {
        var self = this,
            y = self.y,
            height = self.height;

        self.peaks.transition()
          .attr('opacity', 0.8)
          .duration(self.animationDelay) 
          .attr("d", self.peakLine);
        
        self.values.transition(self.animationDelay)
          .duration(self.animationDelay)
          .attr('y', function(d) {return height - y(d.value) - self.dims.values.margin;})
          .style('opacity', 1);

      },
      chartSpecificDataValidate: function() {
          var self = this,
              errors = [],
              numOfPeaks = self.chartData.length;

          // There should be at least value.
          if(numOfPeaks === 0) {
            errors.push({input: numOfPeaks, msg: 'Please provide at least one value for the chart.'});
          } else {
            for (var i=0; i < numOfPeaks; i++){
              
              // There should be a value for every bar.
              if (!self.chartData[i].value){ 
                errors.push({ input: self.chartData, msg: 'You must include a value for every peak.'});
              }
              
              // There should be a label for every bar.
              if (!self.chartData[i].label){ 
                errors.push({ input: self.chartData, msg: 'You must include a label for every peak.'});
              }
            }
          }

          return errors;
        }
      
    });


  </script>
</polymer-element>
