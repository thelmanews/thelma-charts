<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="th-d3-chart.html">

<polymer-element name="th-n-peak-chart" extends="th-d3-chart">

  <script>
    Polymer('th-n-peak-chart', {
      chartData: [
        {label: 'Platinum', value: 50, display_value: '$50'},
        {label: 'Gold', value: 45, display_value: '$45'},
        {label: 'Silver', value: 30, display_value: '$30'},
        {label: 'Bronze', value: 25, display_value: '$25'}
      ],
      init: function() {
        var self = this;

        // setup dimensions
        self.dims = self.setupDimensions(self);
        self.width = self.dims.width;
        self.height = self.dims.height;
    
        // format chart elements based on chartData
        self.barDims = self.setupBarDims(self, 1.25); // pass in overlap to override default
        self.labelDims = self.setupLabelDims(self);
        self.valueDims = self.setupValueDims(self);
     
        // create scales
        self.scales = self.simpleScaleBuilder(self.width, self.height, self.chartData);
        
        // setup container, rearrange data for peaks, setup starting state of peaks
        self.peakData = self._setupData();
        self._setupElements();
        self._setupElementSizes();

        self.dataLength = self.peakData.length;

      },

      _setupData: function(){
        var self = this,
            barDims = self.dims.bars
            height = self.dims.height,
            y = self.scales.y,
            lastEdge = 0;

        var peakData = self.chartData.map(function(i){
          var coordinates = [{ x: lastEdge, y: -height},
                           {x: lastEdge + barDims.width, y: -height},
                           { x: lastEdge + barDims.width/2, y: -height+y(i.value)}];
          lastEdge = lastEdge + (barDims.width/barDims.overlap)/barDims.overlap;
          return coordinates;
        });
        return peakData;
      },
      _setupElements: function(){
        var self = this,
            peakData = self.peakData;

        self.svg = d3.select(self.$.chart);

        self.container = self.svg
            .selectAll('.container')
            .data([1])
            .enter()
            .append('g')
            .attr('class','container');

        self.peakLineStart = d3.svg.line()
            .x(function(d) { return d.x; })
            .y(function(d) { return height; });

        self.peaks = self.container.selectAll('.peak')
          .data(peakData)
          .enter()
          .append('path')
            .attr('class', function(d,i){return "peak data"+i;})
            .attr('d', self.peakLineStart)
            .attr('opacity', 0);

        self.labels = self.container.selectAll('.label')
          .data(self.chartData)
          .enter().append('text')
            .attr('class', function(d,i){return "label data"+i;});              
            
        self.values = self.container.selectAll('.value')
          .data(self.chartData)
          .enter().append('text')
            .attr('class', function(d,i){return "value data"+i;}).attr('y', height);
            
      },
      _setupContainerSize: function(){ //
        var self = this,
            margin = self.dims.margin,
            width = self.dims.width,
            height = self.dims.height;
            self.svg = d3.select(self.$.chart);

        self.svg
            .attr('width', width + margin.left + margin.right)
            .attr('height', height + margin.top + margin.bottom);

        // setting up the size. needed for resizing
        self.container.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

      },

      _setupElementSizes: function(){
        var self = this,
            barDims = self.barDims,
            labelDims = self.labelDims,
            valueDims = self.valueDims,
            peakData = self.peakData
            height = self.height;

        self._setupContainerSize();

        // starting and ending lines to draw peaks

        self.peakLine = d3.svg.line()
            .x(function(d) { return d.x; })
            .y(function(d) { return -d.y; });    

        self.peaks
          .data(peakData);

        self.labels
            .attr('text-anchor', function(){ return labelDims.angle > 0 ? "left" : "middle"})
            .attr('transform', function(d,i){
              var xPos = (barDims.width/2) + (barDims.width/barDims.overlap*i/barDims.overlap);
              var yPos = height + 16;
              var rotation = labelDims.angle;
              return "translate("+xPos+","+yPos+") rotate("+ rotation +")";
            })
            .text(function(d) {return d.label;});

        self.values
            .attr('text-anchor','middle')
            .attr('font-size', valueDims.size)
            .style('opacity', 0)
            .attr('x', function(d,i) { return ((barDims.width/2) + (barDims.width/barDims.overlap*i/barDims.overlap)); })
            .text(function(d) {return d.display_value ? d.display_value : d.value ;});

      },
      reset: function() {
        var self = this,
            height= self.height;
        self.peaks.transition().duration(self.animationDelay).attr('d', self.peakLineStart).attr('opacity', 0);
        self.values.transition().duration(self.animationDelay).attr('y', height ).style('opacity', 0);
          
      },
      
      animate: function() {
        var self = this,
            y = self.scales.y,
            height = self.height;

        self.peaks.transition()
          .attr('opacity', 0.8)
          .duration(self.animationDelay) 
          .attr("d", self.peakLine);
        
        self.values.transition(self.animationDelay)
          .duration(self.animationDelay)
          .attr('y', function(d) {return height - y(d.value) - self.dims.values.margin;})
          .style('opacity', 1);

      },
      resize: function(){
        var self = this;

        // setup dimensions
        self.dims = self.setupDimensions(self);
        self.width = self.dims.width;
        self.height = self.dims.height;

        // format chart elements based on chartData
        self.barDims = self.setupBarDims(self, 1.25); // pass in overlap to override default
        self.labelDims = self.setupLabelDims(self);
        self.valueDims = self.setupValueDims(self);

        // create scales
        self.scales = self.simpleScaleBuilder(self.width, self.height, self.chartData);
       
        // setup container, rearrange data for peaks, setup starting state of peaks
        self.peakData = self._setupData();
        self._setupElementSizes();
        self.animate();
      },
      updateData: function(){
        var self = this;

        self.peakData = self._setupData();

        self.peaks = self.container.selectAll('.peak').data(self.peakData);
        self.labels = self.container.selectAll('.label').data(self.chartData);
        self.values = self.container.selectAll('.value').data(self.chartData);

        if(self.dataLength!=self.peakData.length) {
          
          self.dataLength = self.peakData.length;
          

          self.peaks.enter().append('path').attr('class',function(d,i){return "peak data"+i;})
            .attr('height', 0)
            .attr('y', height)
            .attr('d', self.peakLineStart)
            .attr('opacity', 0);
          self.labels.enter().append('text').attr('class',function(d,i){return "label data"+i;});
          self.values.enter().append('text').attr('class', function(d,i){return "value data"+i;}).attr('y', height);

          self.peaks.exit().remove();
          self.labels.exit().remove();
          self.values.exit().remove();
          self.resize();
        }
          // this is independent of size but dependent on data
          self.labels.text(function(d) {return d.label;});
          self.values.text(function(d) {return d.display_value ? d.display_value : d.value ;});
          self.animate();
        
      },
      chartSpecificDataValidate: function() {
          var self = this,
              errors = [],
              numOfPeaks = self.chartData.length;

          // There should be at least value.
          if(numOfPeaks === 0) {
            errors.push({input: numOfPeaks, msg: 'Please provide at least one value for the chart.'});
          } else {
            for (var i=0; i < numOfPeaks; i++){
              
              // There should be a value for every bar.
              if (!self.chartData[i].value){ 
                errors.push({ input: self.chartData, msg: 'You must include a value for every peak.'});
              }
              
              // There should be a label for every bar.
              if (!self.chartData[i].label){ 
                errors.push({ input: self.chartData, msg: 'You must include a label for every peak.'});
              }
            }
          }

          return errors;
        }
      
    });


  </script>
</polymer-element>
