<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="th-d3-chart.html">

<polymer-element name="th-n-peak-chart" extends="th-d3-chart">

  <script>
    Polymer('th-n-peak-chart', {
      chartData: [
        {label: 'Platinum', value: 50, display_value: '$50'},
        {label: 'Gold', value: 45, display_value: '$45'},
        {label: 'Silver', value: 30, display_value: '$30'},
        {label: 'Bronze', value: 25, display_value: '$25'}   
      ],
      init: function() {
        var self = this;
          
        self.dims = self.setupDimensions(self);

        var margin = self.dims.margin,
              width = self.dims.width,
              height = self.dims.height;

          self.height = height;

          // peak declarations
          var numOfPeaks = self.chartData.length, 
              overlap = 1.2, // the higher the number, the more overlap
              peakWidth = (width / numOfPeaks)*overlap,
              peakWidthOverlap = peakWidth*overlap;
          var peakLineStart = d3.svg.line()
              .x(function(d) { return d.x; })
              .y(function(d) { return height; });
          var peakLine = d3.svg.line()
              .x(function(d) { return d.x; })
              .y(function(d) { return -d.y; });
          self.peakLine = peakLine;
          self.peakLineStart = peakLineStart;

          // scales
          var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
          var y = d3.scale.linear().range([0, height]);
          self.y = y;

          // chart positioning
          var chart_svg = self.$.chart;

          self.container = d3.select(chart_svg).attr('width', width + margin.left + margin.right)
              .attr('height', height + margin.top + margin.bottom)
              .append('g')
              .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
          var max = d3.max(self.chartData, function(d) {return d.value});

          y.domain([0, max]); 
          x.domain(self.chartData.map(function(d) {
            return d.label;
          }));
 
          // transform chartData for paths
          var lastEdge = 0;
          var peakData = self.chartData.map(function(i){
          var coordinates = [{ x: lastEdge, y: -height},
                             {x: lastEdge + peakWidth, y: -height},
                             { x: lastEdge + peakWidth/2, y: -height+y(i.value)}];
            lastEdge = lastEdge + (peakWidth/overlap)/overlap;
            return coordinates;
          });

          // append peaks
          self.peaks = self.container.selectAll('.peak')
            .data(peakData)
            .enter()
            .append('path')
              .attr('class', function(d,i){return "peak data"+i;})
              .attr('d', peakLineStart)
              .attr('opacity', 0);
      
          // append labels
          self.labels = self.container.selectAll('.label')
            .data(self.chartData)
            .enter().append('text')
              .attr('class', function(d,i){return "label data"+i;})
              //.style('opacity', 0)
              .style('text-anchor','middle')
              .attr('x', function(d,i) { return ((peakWidth/2) + (peakWidth/overlap*i/overlap)); })
              .attr('y', height + 14) //12: font size
              .text(function(d) {return d.label;});
            
          // append values  
          self.values = self.container.selectAll('.value')
            .data(self.chartData)
            .enter().append('text')
              .attr('class', function(d,i){return "value data"+i;})
              .style('text-anchor','middle')
              .style('opacity', 0)
              .attr('x', function(d,i) { return ((peakWidth/2) + (peakWidth/overlap*i/overlap)); })
              .text(function(d) {return d.display_value ? d.display_value : d.value ;});

      },
      reset: function() {
          var self = this;
          var height= self.height;
          self.peaks.transition().duration(self.animationDelay).attr('d', self.peakLineStart).attr('opacity', 0);
          self.values.transition().duration(self.animationDelay).attr('y', height ).style('opacity', 0);
          
      },
      
      animate: function() {
            var self = this;
            var y = self.y;
            var height= self.height;

            self.peaks.transition()
              .attr('opacity', 0.8)
              .duration(self.animationDelay) 
              .attr("d", self.peakLine);
            
            self.values.transition(self.animationDelay)
              .duration(self.animationDelay)
              .attr('y', function(d) {return height - y(d.value) - 2;})
              .style('opacity', 1);

      },
      chartSpecificDataValidate: function() {
          var self = this;
          var errors = [],
              numOfPeaks = self.chartData.length;

          // There should be at least value.
          if(numOfPeaks === 0) {
            errors.push({input: numOfPeaks, msg: 'Please provide at least one value for the chart.'});
          } else {
            for (var i=0; i < numOfPeaks; i++){
              
              // There should be a value for every bar.
              if (!self.chartData[i].value){ 
                errors.push({ input: self.chartData, msg: 'You must include a value for every peak.'});
              }
              
              // There should be a label for every bar.
              if (!self.chartData[i].label){ 
                errors.push({ input: self.chartData, msg: 'You must include a label for every peak.'});
              }
            }
          }

          return errors;
        }
      
    });


  </script>
</polymer-element>
