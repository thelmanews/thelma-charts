<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="th-d3-chart.html">

<polymer-element name="th-n-peak-chart" extends="th-d3-chart">

  <script>
    Polymer('th-n-peak-chart', {
      chartData: [
        {label: 'Platinum', value: 50, display_value: '$50'},
        {label: 'Gold', value: 45, display_value: '$45'},
        {label: 'Silver', value: 30, display_value: '$30'},
        {label: 'Bronze', value: 25, display_value: '$25'}
      ],
      init: function() {
        var self = this;
        self.dims = self.setupDimensions(self);

        var margin = self.dims.margin,
            width = self.dims.width,
            height = self.dims.height;
        self.height = height;

        // format based on chartData
        var bars = self.formatBars(1.25); // pass in overlap to override default
        var labels = self.formatLabels();
        var values = self.formatValues();

        // creating scales
        var scales = self.simpleScaleBuilder(width, height, self.chartData);
        var x = scales.x;
        var y = scales.y;
        self.y = y;
        self.x = x;

        // chart positioning
        var chart_svg = self.$.chart;

        self.container = d3.select(chart_svg).attr('width', width + margin.left + margin.right)
            .attr('height', height + margin.top + margin.bottom)
            .append('g')
            .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
        var max = d3.max(self.chartData, function(d) {return d.value});


        // starting and ending lines to draw peaks
        var peakLineStart = d3.svg.line()
              .x(function(d) { return d.x; })
              .y(function(d) { return height; });
        var peakLine = d3.svg.line()
              .x(function(d) { return d.x; })
              .y(function(d) { return -d.y; });
          self.peakLine = peakLine;
          self.peakLineStart = peakLineStart;
 
        // transform chartData for paths
        var lastEdge = 0;
        var peakData = self.chartData.map(function(i){
          var coordinates = [{ x: lastEdge, y: -height},
                           {x: lastEdge + self.dims.bars.width, y: -height},
                           { x: lastEdge + self.dims.bars.width/2, y: -height+y(i.value)}];
          lastEdge = lastEdge + (self.dims.bars.width/self.dims.bars.overlap)/self.dims.bars.overlap;
          return coordinates;
        });

        // append peaks
        self.peaks = self.container.selectAll('.peak')
          .data(peakData)
          .enter()
          .append('path')
            .attr('class', function(d,i){return "peak data"+i;})
            .attr('d', peakLineStart)
            .attr('opacity', 0);
    
        // append labels
        self.labels = self.container.selectAll('.label')
          .data(self.chartData)
          .enter().append('text')
            .attr('class', function(d,i){return "label data"+i;})              
            .style('text-anchor', function(){ return labels.angle > 0 ? "left" : "middle"})
            .attr('transform', function(d,i){
              var xPos = (bars.width/2) + (bars.width/bars.overlap*i/bars.overlap);
              var yPos = height + 16;
              var rotation = labels.angle;
              return "translate("+xPos+","+yPos+") rotate("+ rotation +")";
            })
            .text(function(d) {return d.label;});
          
        // append values  
        self.values = self.container.selectAll('.value')
          .data(self.chartData)
          .enter().append('text')
            .attr('class', function(d,i){return "value data"+i;})
            .style('text-anchor','middle')
            .attr('font-size', values.size)
            .style('opacity', 0)
            .attr('x', function(d,i) { return ((bars.width/2) + (bars.width/bars.overlap*i/bars.overlap)); })
            .attr('y', height)
            .text(function(d) {return d.display_value ? d.display_value : d.value ;});

      },
      formatBars: function(overlap, gap){ // MOVE TO UTILS?
          var self = this,
              dims = self.dims,
              chartData = self.chartData;

          dims.bars = {};
          dims.bars.count = chartData.length;
          dims.bars.overlap = overlap || 1; // the higher the number, the more overlap
          dims.bars.gap = gap || 1;
          dims.bars.width = (dims.width / dims.bars.count)* dims.bars.overlap / dims.bars.gap;
          dims.bars.widthOverlap = dims.bars.width*dims.bars.overlap;
       
          return dims.bars
      },
      formatValues: function(){ // MOVE TO UTILS?
        var self = this,
            dims = self.dims,
            chartData = self.chartData;
        
        dims.values = {};
        dims.values.maxLength = d3.max(chartData, function(d){  
          return  d.display_value ? d.display_value.length : d.value.toString().length;
         });
        dims.values.size = Math.min(30,((dims.bars.width/2) / dims.values.maxLength / 0.6) );
        dims.values.spacing = dims.values.size * 0.25;

        // Adjust top margin as necessary
        if ((dims.values.size+dims.values.spacing) > dims.margin.top) { 
          dims.margin.top = dims.values.size+dims.values.spacing;
        }

        return dims.values;

      },
      formatLabels: function(){ // MOVE TO UTILS?
          // Check if labels overlap and angle them if they do
          var self = this,
              chartData = self.chartData,
              dims = self.dims;
          
          dims.labels = {};
          dims.labels.maxLength = d3.max(chartData, function(d){ return  d.label.length;}); 
          dims.labels.width = dims.labels.maxLength * 5.25; // This calc works with the font-size 13px

          // If labels are long, angle them and adjust margin
          if (dims.labels.width > dims.bars.width/1.6) { 
            dims.labels.angle = 25;
            dims.margin.bottom = dims.labels.width;
            dims.margin.right = dims.labels.width;
            
            // need to adjust margin right when last label is long, so it does not cut off
          } else {
            dims.labels.angle = 0;
          }

          return dims.labels;
      },
      chartSetup: function(){

      },
      reset: function() {
          var self = this;
          var height= self.height;
          self.peaks.transition().duration(self.animationDelay).attr('d', self.peakLineStart).attr('opacity', 0);
          self.values.transition().duration(self.animationDelay).attr('y', height ).style('opacity', 0);
          
      },
      
      animate: function() {
            var self = this;
            var y = self.y;
            var height= self.height;

            self.peaks.transition()
              .attr('opacity', 0.8)
              .duration(self.animationDelay) 
              .attr("d", self.peakLine);
            
            self.values.transition(self.animationDelay)
              .duration(self.animationDelay)
              .attr('y', function(d) {return height - y(d.value) - self.dims.values.spacing;})
              .style('opacity', 1);

      },
      chartSpecificDataValidate: function() {
          var self = this;
          var errors = [],
              numOfPeaks = self.chartData.length;

          // There should be at least value.
          if(numOfPeaks === 0) {
            errors.push({input: numOfPeaks, msg: 'Please provide at least one value for the chart.'});
          } else {
            for (var i=0; i < numOfPeaks; i++){
              
              // There should be a value for every bar.
              if (!self.chartData[i].value){ 
                errors.push({ input: self.chartData, msg: 'You must include a value for every peak.'});
              }
              
              // There should be a label for every bar.
              if (!self.chartData[i].label){ 
                errors.push({ input: self.chartData, msg: 'You must include a label for every peak.'});
              }
            }
          }

          return errors;
        }
      
    });


  </script>
</polymer-element>
