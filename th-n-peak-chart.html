<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="th-d3-chart.html">

<polymer-element name="th-n-peak-chart" extends="th-d3-chart">

  <script>


    (function() {


      //  static private methods and private attributes ...
      var privateObj = {};

      // adding methods from mixin object to privateObj
      Thelma.BarFamilyPrivateStaticMethods.apply(privateObj);

      
      // Adding private static methods.

      privateObj._setupData = function(self){
          
          var barDims = privateObj.dims.bars,
              height = privateObj.dims.height,
              y = privateObj.scales.y,
              lastEdge = 0;

          var peakData = self.chartData.map(function(i){
            var coordinates = [{ x: lastEdge, y: -height},
                             {x: lastEdge + barDims.width, y: -height},
                             { x: lastEdge + barDims.width/2, y: -height+y(i.value)}];
            lastEdge = lastEdge + (barDims.width/barDims.overlap)/barDims.overlap;
            return coordinates;
          });
          return peakData;
        
        },

        privateObj._setupElements = function(self){
          var peakData = privateObj.peakData,
              labelDims = privateObj.dims.labels,//privateObj.labelDims,
              barDims = privateObj.dims.bars;//privateObj.barDims;

          // console.log(privateObj.dims);
          // console.log(labelDims);
          // console.log(labelDims.angle);

          privateObj.svg = d3.select(self.$.chart);

          privateObj.container = privateObj.svg
              .selectAll('.container')
              .data([1])
              .enter()
              .append('g')
              .attr('class','container');

          privateObj.peakLineStart = d3.svg.line()
              .x(function(d) { return d.x; })
              .y(function(d) { return privateObj.dims.height; });

          privateObj.peaks = privateObj.container.selectAll('.peak')
            .data(peakData)
            .enter()
            .append('path')
              .attr('class', function(d,i){return "peak data"+i;})
              .attr('d', privateObj.peakLineStart)
              .attr('opacity', 0);

          privateObj.labels = privateObj.container.selectAll('.label')
            .data(self.chartData)
            .enter().append('text')
              .attr('class', function(d,i){return "label data"+i;})
              .attr('transform', function(d,i){
                var xPos = (barDims.width/2) + (barDims.width/barDims.overlap*i/barDims.overlap);
                var yPos = privateObj.dims.height + privateObj.dims.margin.label;
                var rotation = labelDims.angle;
                return "translate("+xPos+","+yPos+") rotate("+ rotation +")";
              });              
              
          privateObj.values = privateObj.container.selectAll('.value')
            .data(self.chartData)
            .enter().append('text')
              .attr('class', function(d,i){return "value data"+i;})
              .attr('y', privateObj.dims.height);
              
        },
        privateObj._setupContainerSize = function(self){ //
          var margin = privateObj.dims.margin,
              width = privateObj.dims.width,
              height = privateObj.dims.height;
              privateObj.svg = d3.select(self.$.chart);

          privateObj.svg
              .attr('width', width + margin.left + margin.right)
              .attr('height', height + margin.top + margin.bottom);

          // setting up the size. needed for resizing
          privateObj.container.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

        },

        privateObj._setupElementSizes = function(self){
          var barDims = privateObj.barDims,
              labelDims = privateObj.dims.labels,//privateObj.labelDims,
              barDims = privateObj.dims.bars,//privateObj.barDims;
              valueDims = privateObj.dims.values,//privateObj.barDims;
              peakData = privateObj.peakData
              height = privateObj.height;

          privateObj._setupContainerSize(self);

          // starting and ending lines to draw peaks

          privateObj.peakLine = d3.svg.line()
              .x(function(d) { return d.x; })
              .y(function(d) { return -d.y; });    

          privateObj.peaks
            .data(peakData);

          privateObj.labels
              .attr('text-anchor', function(){ return labelDims.angle > 0 ? "left" : "middle"})
              .text(function(d) {return d.label;});

          privateObj.values
              .attr('text-anchor','middle')
              .attr('font-size', valueDims.size)
              .text(function(d) {return d.display_value ? d.display_value : d.value ;});

        },

      
      // Adding private static methods.

      Polymer('th-n-peak-chart', {
        chartData: [
          {label: 'Platinum', value: 50, display_value: '$50'},
          {label: 'Gold', value: 45, display_value: '$45'},
          {label: 'Silver', value: 30, display_value: '$30'},
          {label: 'Bronze', value: 25, display_value: '$25'}
        ],
        init: function() {
          var self = this;

          // setup dimensions
          privateObj.dims = self.setupDimensions(self);
          privateObj.width = privateObj.dims.width;   //TODO needed?
          privateObj.height = privateObj.dims.height;

          privateObj.dims = privateObj.setupBarLabelDims(privateObj.dims, self.chartData);

      
          // format chart elements based on chartData
          //privateObj.barDims = privateObj.setupBarDims(self, 1.25); // pass in overlap to override default
          //privateObj.labelDims = privateObj.setupLabelDims(self);
          //privateObj.valueDims = privateObj.setupValueDims(self);
       
          // create scales
          privateObj.scales = self.simpleScaleBuilder(privateObj.width, privateObj.height, self.chartData);
          
          // setup container, rearrange data for peaks, setup starting state of peaks
          privateObj.peakData = privateObj._setupData(self);
          privateObj._setupElements(self);
          privateObj._setupElementSizes(self);

          privateObj.dataLength = privateObj.peakData.length;

        },


        reset: function(hard) {
          var self = this,
              height= privateObj.height;
          if(hard) {
            privateObj.peaks.attr('d', privateObj.peakLineStart).attr('opacity', 0);
            privateObj.values.attr('y', height ).style('opacity', 0);

          }
          else {    
            privateObj.peaks.transition().duration(privateObj.animationDelay).attr('d', privateObj.peakLineStart).attr('opacity', 0);
            privateObj.values.transition().duration(privateObj.animationDelay).attr('y', height ).style('opacity', 0);
          }
        },
        
        animate: function() {
          var self = this,
              y = privateObj.scales.y,
              height = privateObj.height,
              labelDims = privateObj.dims.labels,//privateObj.labelDims,
              barDims = privateObj.dims.bars,//privateObj.barDims;
              valueDims = privateObj.dims.values;//privateObj.barDims;


          privateObj.peaks.transition()
            .attr('opacity', 0.8)
            .duration(self.animationDelay) 
            .attr("d", privateObj.peakLine);
          
          privateObj.values.transition(self.animationDelay)
            .duration(self.animationDelay)
            .attr('y', function(d) {return height - y(d.value) - privateObj.dims.values.margin;})
            .attr('x', function(d,i) { return ((barDims.width/2) + (barDims.width/barDims.overlap*i/barDims.overlap)); })
            .style('opacity', 1);

          privateObj.labels.transition(self.animationDelay)
            .duration(self.animationDelay)
            .attr('transform', function(d,i){
                var xPos = (barDims.width/2) + (barDims.width/barDims.overlap*i/barDims.overlap);
                var yPos = height + privateObj.dims.margin.label;
                var rotation = labelDims.angle;
                return "translate("+xPos+","+yPos+") rotate("+ rotation +")";
              })
            .style('opacity', 1);

        },
        resize: function(){
          var self = this;

          // setup dimensions
          privateObj.dims = self.setupDimensions(self);
          privateObj.width = privateObj.dims.width;
          privateObj.height = privateObj.dims.height;

          // format chart elements based on chartData
          // privateObj.barDims = privateObj.setupBarDims(self, 1.25); // pass in overlap to override default
          // privateObj.labelDims = privateObj.setupLabelDims(self);
          // privateObj.valueDims = privateObj.setupValueDims(self);

          privateObj.dims = privateObj.setupBarLabelDims(privateObj.dims, self.chartData);

          // create scales
          privateObj.scales = self.simpleScaleBuilder(privateObj.width, privateObj.height, self.chartData);
         
          // setup container, rearrange data for peaks, setup starting state of peaks
          privateObj.peakData = privateObj._setupData(self);
          privateObj._setupElementSizes(self);
          self.animate();
        },
        updateData: function(){
          var self = this,
              barDims = privateObj.dims.bars,
              labelDims = privateObj.dims.labels;

          privateObj.peakData = privateObj._setupData(self);

          privateObj.peaks = privateObj.container.selectAll('.peak').data(privateObj.peakData);
          privateObj.labels = privateObj.container.selectAll('.label').data(self.chartData);
          privateObj.values = privateObj.container.selectAll('.value').data(self.chartData);

          if(privateObj.dataLength!=privateObj.peakData.length) {
            
            privateObj.dataLength = privateObj.peakData.length;
            

            privateObj.peaks.enter().append('path').attr('class',function(d,i){return "peak data"+i;})
              .attr('height', 0)
              .attr('y', height)
              .attr('d', privateObj.peakLineStart)
              .attr('opacity', 0);
            privateObj.labels.enter().append('text').attr('class',function(d,i){return "label data"+i;})
              .attr('transform', function(d,i){
                var xPos = (barDims.width/2) + (barDims.width/barDims.overlap*i/barDims.overlap);
                var yPos = height + privateObj.dims.margin.label;
                var rotation = labelDims.angle;
                return "translate("+xPos+","+yPos+") rotate("+ rotation +")";
              });
            privateObj.values.enter().append('text')
              .attr('class', function(d,i){return "value data"+i;})
              .attr('y', height);

            privateObj.peaks.exit().remove();
            privateObj.labels.exit().remove();
            privateObj.values.exit().remove();
            self.resize();
          }
            // this is independent of size but dependent on data
            privateObj.labels.text(function(d) {return d.label;});
            privateObj.values.text(function(d) {return d.display_value ? d.display_value : d.value ;});
            self.animate();
          
        },
        chartSpecificDataValidate: function() {
            var self = this,
                errors = [],
                numOfPeaks = self.chartData.length;

            // There should be at least value.
            if(numOfPeaks === 0) {
              errors.push({input: numOfPeaks, msg: 'Please provide at least one value for the chart.'});
            } else {
              for (var i=0; i < numOfPeaks; i++){
                
                // There should be a value for every bar.
                if (!self.chartData[i].value){ 
                  errors.push({ input: self.chartData, msg: 'You must include a value for every peak.'});
                }
                
                // There should be a label for every bar.
                if (!self.chartData[i].label){ 
                  errors.push({ input: self.chartData, msg: 'You must include a label for every peak.'});
                }
              }
            }

            return errors;
          }
        
      });
  
  })();


  </script>
</polymer-element>
