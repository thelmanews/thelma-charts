<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="th-d3-chart.html">

<polymer-element name="th-n-peak-chart" extends="th-d3-chart">

  <script>
    Polymer('th-n-peak-chart', {
      chartData: [
        {label: 'Platinum', value: 50, display_value: '$50'},
        {label: 'Gold', value: 45, display_value: '$45'},
        {label: 'Silver', value: 30, display_value: '$30'},
        {label: 'Bronze', value: 25, display_value: '$25'}   
      ],
      init: function() {
        var self = this;
          
        self.dims = self.setupDimensions(self);

        var margin = self.dims.margin,
              width = self.dims.width,
              height = self.dims.height;

          self.height = height;

          // peak formats
          var numOfPeaks = self.chartData.length, 
              overlap = 1.2, // the higher the number, the more overlap
              peakWidth = (width / numOfPeaks)*overlap,
              peakWidthOverlap = peakWidth*overlap;
          var peakLineStart = d3.svg.line()
              .x(function(d) { return d.x; })
              .y(function(d) { return height; });
          var peakLine = d3.svg.line()
              .x(function(d) { return d.x; })
              .y(function(d) { return -d.y; });
          self.peakLine = peakLine;
          self.peakLineStart = peakLineStart;

          // Value dimensions
          self.dims.maxValueLength = d3.max(self.chartData, function(d){  
            return  d.display_value ? d.display_value.length : d.value.toString().length;
           });
          self.dims.valueSize = Math.min(30,((peakWidth/2) / self.dims.maxValueLength / 0.6) );
          self.dims.spacing = self.dims.valueSize * 0.25;

          // Adjust top margin as necessary
          if ((self.dims.valueSize+self.dims.spacing) > self.dims.margin.top) { 
            self.dims.margin.top = self.dims.valueSize+self.dims.spacing;
          }

          // Check if labels overlap
          self.dims.maxLabelLength = d3.max(self.chartData, function(d){ return  d.label.length;}); 
          self.dims.labelWidthEst = self.dims.maxLabelLength * 5.25; // This calc works with the font-size 13px

          // If labels are long, angle them and adjust margin
          if (self.dims.labelWidthEst > peakWidth/1.5) { 
            self.dims.labelAngle = 25;
            self.dims.margin.bottom = self.dims.labelWidthEst;
            // need to adjust margin right when last label is long, so it does not cut off
          } else {
            self.dims.labelAngle = 0;
          }


          // creating scales
          var scales = self.simpleScaleBuilder(width, height, self.chartData);

          var x = scales.x;
          var y = scales.y;

          // is there a better way than exposing these?!
          self.y = y;
          self.x = x;

          // chart positioning
          var chart_svg = self.$.chart;

          self.container = d3.select(chart_svg).attr('width', width + margin.left + margin.right)
              .attr('height', height + margin.top + margin.bottom)
              .append('g')
              .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
          var max = d3.max(self.chartData, function(d) {return d.value});
 
          // transform chartData for paths
          var lastEdge = 0;
          var peakData = self.chartData.map(function(i){
          var coordinates = [{ x: lastEdge, y: -height},
                             {x: lastEdge + peakWidth, y: -height},
                             { x: lastEdge + peakWidth/2, y: -height+y(i.value)}];
            lastEdge = lastEdge + (peakWidth/overlap)/overlap;
            return coordinates;
          });

          // append peaks
          self.peaks = self.container.selectAll('.peak')
            .data(peakData)
            .enter()
            .append('path')
              .attr('class', function(d,i){return "peak data"+i;})
              .attr('d', peakLineStart)
              .attr('opacity', 0);
      
          // append labels
          self.labels = self.container.selectAll('.label')
            .data(self.chartData)
            .enter().append('text')
              .attr('class', function(d,i){return "label data"+i;})              
              .style('text-anchor', function(){ return self.dims.labelAngle > 0 ? "left" : "middle"})
              .attr('transform', function(d,i){
                var xPos = (peakWidth/2) + (peakWidth/overlap*i/overlap);
                var yPos = height + 16;
                var rotation = self.dims.labelAngle;
                return "translate("+xPos+","+yPos+") rotate("+ rotation +")"
              })
              .text(function(d) {return d.label;});
            
          // append values  
          self.values = self.container.selectAll('.value')
            .data(self.chartData)
            .enter().append('text')
              .attr('class', function(d,i){return "value data"+i;})
              .style('text-anchor','middle')
              .attr('font-size', self.dims.valueSize)
              .style('opacity', 0)
              .attr('x', function(d,i) { return ((peakWidth/2) + (peakWidth/overlap*i/overlap)); })
              .text(function(d) {return d.display_value ? d.display_value : d.value ;});

      },
      reset: function() {
          var self = this;
          var height= self.height;
          self.peaks.transition().duration(self.animationDelay).attr('d', self.peakLineStart).attr('opacity', 0);
          self.values.transition().duration(self.animationDelay).attr('y', height ).style('opacity', 0);
          
      },
      
      animate: function() {
            var self = this;
            var y = self.y;
            var height= self.height;

            self.peaks.transition()
              .attr('opacity', 0.8)
              .duration(self.animationDelay) 
              .attr("d", self.peakLine);
            
            self.values.transition(self.animationDelay)
              .duration(self.animationDelay)
              .attr('y', function(d) {return height - y(d.value) - self.dims.spacing;})
              .style('opacity', 1);

      },
      chartSpecificDataValidate: function() {
          var self = this;
          var errors = [],
              numOfPeaks = self.chartData.length;

          // There should be at least value.
          if(numOfPeaks === 0) {
            errors.push({input: numOfPeaks, msg: 'Please provide at least one value for the chart.'});
          } else {
            for (var i=0; i < numOfPeaks; i++){
              
              // There should be a value for every bar.
              if (!self.chartData[i].value){ 
                errors.push({ input: self.chartData, msg: 'You must include a value for every peak.'});
              }
              
              // There should be a label for every bar.
              if (!self.chartData[i].label){ 
                errors.push({ input: self.chartData, msg: 'You must include a label for every peak.'});
              }
            }
          }

          return errors;
        }
      
    });


  </script>
</polymer-element>
